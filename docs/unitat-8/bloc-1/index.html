---
layout: bloc
title: "Bloc 1: Fonaments de bases de dades orientades a objectes"
description: "Principis d'ORM, arquitectura de Hibernate, mapatge d'entitats, gestió de sessions i bones pràctiques de persistència"
keywords: "Hibernate, ORM, persistència, PostgreSQL, DAO, transaccions, JPA"
unitat: 8
bloc: 1
bloc_numero: 1
---

<!--
  Bloc 1 (Unitat 8) basat en:
  - material-hibernate-postgresql-v2.pdf (conceptes i aprofundiment teòric)
  - tutorial-hibernate-postgresql-vscode.pdf (context pràctic de suport)
  Objectiu: consolidar RA8 i RA9 abans del tutorial pràctic del Bloc 2.
-->

<div class="section">
    <h2 id="Unitat8_Bloc1_Seccio1">Introducció a la persistència i ORM</h2>

    {% include objectius.html llista="Comprendre el paper de l'ORM en aplicacions empresarials|Identificar els avantatges de separar lògica de negoci i accés a dades|Relacionar RA8 i RA9 amb processos reals de manteniment" %}

    <p>Les aplicacions empresarials necessiten emmagatzemar i recuperar informació de forma segura i consistent. La <strong>persistència</strong> fa referència a mantenir l'estat dels objectes més enllà de l'execució del programa, habitualment en una base de dades relacional. Sense un marc coherent, la traducció entre objectes i taules genera codi repetitiu, errors subtils i dificultats de manteniment.</p>

    {% include definicio.html terme="ORM (Object-Relational Mapping)" definicio="Tècnica que automatitza la correspondència entre el model d'objectes d'una aplicació i l'esquema relacional d'una base de dades, eliminant gran part del codi SQL explícit." %}

    {% include info_box.html contingut="Hibernate és un dels ORM més utilitzats a l'ecosistema Java. Ofereix compatibilitat amb l'especificació JPA, suporta múltiples bases de dades (PostgreSQL, MySQL, Oracle...) i disposa de mecanismes avançats de cache, validació i gestió de transaccions." %}

    {% include suggeriment.html contingut="Imagina que Hibernate actua com un intèrpret simultani: escolta les peticions dels teus objectes Java i les tradueix a SQL perfecte per a PostgreSQL, sense que t'hagis de preocupar pels detalls de la gramàtica." %}

    <p>Sense un ORM, cada equip ha de mantenir codi de baix nivell per establir connexions, construir SQL i transformar resultats en objectes. Aquest patró és repetitiu, difícil de provar i especialment fràgil quan l'esquema de la base de dades evoluciona.</p>

    <p>En el context del mòdul, RA8 cobreix la <em>persistència de dades</em> i RA9 se centra en la <em>gestió i manteniment</em>. Hibernate uneix ambdós resultats: permet definir lògiques d'accés que són alhora eficients i sostenibles al llarg del temps.</p>

    <p><em>Per visualitzar-ho millor, contrasta el flux manual amb el que ofereix Hibernate.</em></p>

    <h3>Sense Hibernate vs amb Hibernate</h3>

    <h4>Sense Hibernate: codi orientat a taules</h4>
    <p>El desenvolupador treballa amb files i columnes. Cada consulta requereix construir SQL, gestionar recursos i transformar els resultats en objectes manualment.</p>

    {% capture code_jdbc %}
String sql = "SELECT id, nom, preu FROM productes WHERE id = ?";
try (Connection conn = DriverManager.getConnection(url, user, pass);
     PreparedStatement ps = conn.prepareStatement(sql)) {
    ps.setLong(1, 42L);
    try (ResultSet rs = ps.executeQuery()) {
        if (rs.next()) {
            Long id = rs.getLong("id");
            String nom = rs.getString("nom");
            BigDecimal preu = rs.getBigDecimal("preu");
            // TODO: crear i omplir l'objecte Producte manualment
        }
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_jdbc %}

    <p>El codi està lligat a l'estructura de la taula (<code>id</code>, <code>nom</code>, <code>preu</code>) i duplica la lògica de mapeig a tots els mètodes.</p>

    <h4>Amb Hibernate: codi orientat a objectes</h4>
    <p>En lloc de manipular files, treballes amb instàncies de classes. Les consultes retornen objectes i només cal aplicar la lògica de negoci.</p>

    {% capture code_hibernate %}
import java.math.BigDecimal;

public class ProducteService {
    private final ProducteDAO producteDAO;

    public ProducteService(ProducteDAO producteDAO) {
        this.producteDAO = producteDAO;
    }

    public void actualitzaPreu(Long id, BigDecimal nouPreu) {
        Producte producte = producteDAO
            .trobarPerId(id)
            .orElseThrow(() -> new IllegalArgumentException("Producte inexistent"));

        producte.setPreu(nouPreu);
        producteDAO.desa(producte);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_hibernate %}

    <p>Hibernate s'encarrega d'obrir la sessió, generar el SQL, sincronitzar els canvis i validar les regles declarades a les anotacions. El desenvolupador se centra en lògica d'objectes.</p>

    <ul>
        <li><strong>Menys codi repetitiu:</strong> el mapeig camp a camp desapareix, reduint errors i duplicacions.</li>
        <li><strong>Coherència i mantenibilitat:</strong> els canvis d'esquema s'apliquen a les entitats i es reflecteixen automàticament a les consultes.</li>
        <li><strong>Abstracció de recursos:</strong> la gestió de connexions i transaccions queda encapsulada, evitant fuites i estats inconsistents.</li>
    </ul>

    {% include prompt-ai.html contingut="Explica en paraules pròpies què guanyes quan substitueixes el patró JDBC manual per Hibernate. Identifica com a mínim dues millores en mantenibilitat." %}
</div>

<div class="section">
    <h2 id="Unitat8_Bloc1_Seccio2">Arquitectura de Hibernate i components clau</h2>

    <p>Hibernate organitza la persistència al voltant de diversos components que cooperen per gestionar sessions, mapatges i transaccions. Comprendre'ls és essencial per diagnosticar problemes i escalar el sistema.</p>

    <table class="responsive-table">
        <thead>
            <tr>
                <th>Component</th>
                <th>Funció principal</th>
                <th>Quan intervenir-hi</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>SessionFactory</code></td>
                <td>Factoría immutable que gestiona la configuració i crea sessions.</td>
                <td>Durant l'arrencada de l'aplicació o quan cal reconfigurar connexions.</td>
            </tr>
            <tr>
                <td><code>Session</code></td>
                <td>Context d'interacció amb la base de dades: carrega, desa i sincronitza entitats.</td>
                <td>A cada operació unitària de negoci (petició web, cas d'ús, procés batch).</td>
            </tr>
            <tr>
                <td><code>Transaction</code></td>
                <td>Garantitza atomicitat i coherència agrupant múltiples operacions.</td>
                <td>Quan es requereix assegurar <em>all-or-nothing</em> en operacions de dades.</td>
            </tr>
            <tr>
                <td><code>Configuration</code></td>
                <td>Carrega propietats i mapatges des de fitxers <code>hibernate.cfg.xml</code> o equivalents.</td>
                <td>En la preparació de l'entorn o quan es despleguen nous mapatges.</td>
            </tr>
        </tbody>
    </table>

    {% include warning_box.html contingut="Evita crear múltiples <code>SessionFactory</code>: és costós i pot saturar la base de dades. Construeix-lo una única vegada i reutilitza'l arreu de l'aplicació." %}

    <p>A nivell de configuració, Hibernate combina propietats (URL, usuari, dialecte SQL), mapatges d'entitats i integració amb l'API JPA. Els fitxers de configuració admeten format XML o propietats, i també es poden establir mitjançant objectes Java o <em>Spring Boot</em>.</p>

    {% include prompt-ai.html contingut="Relaciona cada component de Hibernate amb una tasca concreta del teu projecte (per exemple, quan utilitzaràs la SessionFactory o la Transaction)." %}
</div>

<div class="section">
    <h2 id="Unitat8_Bloc1_Seccio3">Mapatge d'entitats i relacions</h2>

    <p>La clau de qualsevol ORM és descriure com els objectes es corresponen amb les taules relacionals. Hibernate utilitza anotacions JPA o fitxers XML per definir entitats, claus primàries i relacions.</p>

    {% include definicio.html terme="Entitat" definicio="Classe Java persistent que es correspon amb una taula de la base de dades; cada instància representa una fila." %}

    {% capture code_entity %}
import jakarta.persistence.*;
import java.math.BigDecimal;

@Entity
@Table(name = "productes")
public class Producte {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 120)
    private String nom;

    @Column(name = "preu", precision = 10, scale = 2)
    private BigDecimal preu;

    @Enumerated(EnumType.STRING)
    private Categoria categoria;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "proveidor_id")
    private Proveidor proveidor;

    // getters, setters i constructors
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_entity %}

    <p>Les anotacions controlen la traducció a SQL:</p>
    <ul>
        <li><code>@Table</code> defineix la taula i opcionalment l'esquema.</li>
        <li><code>@Column</code> ajusta propietats com la longitud, nul·litat o precisió.</li>
        <li><code>@ManyToOne</code>, <code>@OneToMany</code> i <code>@ManyToMany</code> gestionen relacions amb claus foranes.</li>
    </ul>

    {% include prompt-ai.html contingut="Tria una entitat del teu projecte personal i explica quines anotacions JPA necessitaria. Pots demanar a l'IA que et proposi les anotacions si li facilites els atributs." %}

    {% include success_box.html contingut="Mapatge correcte = menys SQL manual, però no evitarem entendre el model relacional. Cal dissenyar bé l'esquema i validar-lo amb l'equip de bases de dades." %}
</div>

<div class="section">
    <h2 id="Unitat8_Bloc1_Seccio4">Gestió de sessions i transaccions</h2>

    <p>Les sessions actuen com una «unitat de treball». Agrupen totes les operacions que comparteixen un mateix context d'emmagatzematge. Quan una sessió es tanca, Hibernate sincronitza l'estat dels objectes (<em>dirty checking</em>) amb la base de dades.</p>

    {% capture code_session %}
Transaction tx = null;
try (Session session = sessionFactory.openSession()) {
    tx = session.beginTransaction();

    Producte producte = session.get(Producte.class, 42L);
    producte.setPreu(new BigDecimal("24.90"));

    session.persist(producte);

    tx.commit(); // Desar els canvis de forma atòmica
} catch (Exception ex) {
    if (tx != null) {
        tx.rollback(); // Recuperar coherència en cas d'error
    }
    throw ex;
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_session %}

    {% include info_box.html contingut="El <em>dirty checking</em> de Hibernate detecta modificacions sobre entitats gestionades i genera el SQL necessari. Això redueix la quantitat de codi, però cal delimitar correctament les fronteres de la sessió." %}

    {% include warning_box.html contingut="No deixis sessions obertes en aplicacions web. Utilitza patrons com <em>Session per request</em> o el suport transaccional de Spring per assegurar tancaments automàtics." %}
</div>

<div class="section">
    <h2 id="Unitat8_Bloc1_Seccio5">Patró DAO i capa de servei</h2>

    <p>Separar l'accés a dades de la lògica de negoci facilita el manteniment i les proves. El <strong>patró DAO</strong> encapsula les operacions CRUD sobre una entitat, mentre que la <strong>capa de servei</strong> orquestra regles de negoci i transaccions.</p>

    {% include definicio.html terme="DAO (Data Access Object)" definicio="Classe o interfície que centralitza totes les operacions de persistència d'una entitat o agregat." %}

    {% capture code_dao %}
public class ProducteDAO {
    private final SessionFactory sessionFactory;

    public ProducteDAO(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Optional<Producte> trobarPerId(Long id) {
        try (Session session = sessionFactory.openSession()) {
            return Optional.ofNullable(session.get(Producte.class, id));
        }
    }

    public void desa(Producte producte) {
        try (Session session = sessionFactory.openSession()) {
            Transaction tx = session.beginTransaction();
            session.merge(producte);
            tx.commit();
        }
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_dao %}

    <p>La capa de servei pot injectar múltiples DAOs, aplicar regles de validació, gestionar transaccions distribuïdes o coordinar serveis externs. Aquesta separació és crítica per RA9, on cal garantir mantenibilitat i monitoratge.</p>

    {% include prompt-ai.html contingut="Com dividiries la lògica d'un cas d'ús (per exemple, crear una comanda) entre la capa de servei i els DAO? Demana a l'IA que t'ajudi a esbossar els passos." %}
</div>

<div class="section">
    <h2 id="Unitat8_Bloc1_Seccio6">Bones pràctiques i optimització</h2>

    {% include checklist.html titol="Recomanacions clau" elements="Selecciona un dialecte i driver coherent amb la versió de PostgreSQL|Defineix columnes amb longitud i precisió explícita per evitar discrepàncies|Utilitza <em>fetch</em> lazy per relacions que no es necessiten sempre|Activa la segona memòria cau només quan hi ha beneficis mesurables|Registra consultes llogades per detectar N+1 i colls d'ampolla" %}

    <p>Altres aspectes a considerar:</p>
    <ul>
        <li><strong>Validació:</strong> integra <code>Jakarta Bean Validation</code> per assegurar la coherència abans d'arribar a la base de dades.</li>
        <li><strong>Seguretat:</strong> utilitza usuaris amb privilegis limitats i configura SSL si l'entorn ho requereix.</li>
        <li><strong>Migracions:</strong> empra eines com Flyway o Liquibase per versionar canvis estructurals i mantenir entorns alineats.</li>
    </ul>

    {% include prompt-ai.html contingut="Quin seria el teu pla per diagnosticar una consulta Hibernate que triga massa? Detalla tres proves o mètriques a revisar." %}

    <h3>Activitats de pràctica</h3>
    <p>Posa en pràctica el que has après amb aquests exercicis guiats. Pots demanar ajuda a una IA generativa quan t'encallis.</p>

    {% include exercici.html
       nom="Mapatge bàsic d'una entitat"
       dificultat="Fàcil"
       temps="10 min"
       descripcio="<p>Anota la classe <code>Client</code> perquè es pugui persistir amb JPA.</p><p>Indica la clau primària i assegura que l'atribut <code>email</code> no pot ser nul.</p>"
       pistes="Recorda utilitzar @Entity i @Id|Pots definir la longitud màxima amb @Column(length = ...)|La clau primària pot generar-se amb GenerationType.IDENTITY"
    %}

    {% capture code_ex1_base %}
public class Client {
    private Long id;
    private String nom;
    private String email;
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_ex1_base %}

    {% include prompt-ai.html contingut="Demana a l'IA que revisi la teva anotació de la classe <code>Client</code> i et proposi millores (per exemple, restriccions addicionals)." %}

    {% capture solucio_ex1_text %}
<p>Una possible solució anota la classe amb <code>@Entity</code>, defineix la clau primària amb <code>@Id</code> i força que el correu sigui obligatori amb <code>@Column(nullable = false)</code>.</p>
    {% endcapture %}
    {% capture solucio_ex1_code %}
import jakarta.persistence.*;

@Entity
@Table(name = "clients")
public class Client {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 80)
    private String nom;

    @Column(nullable = false, length = 120, unique = true)
    private String email;

    // getters i setters
}
    {% endcapture %}
    <details class="solution-toggle">
        <summary>Mostra la solució</summary>
        {% include solucio.html contingut=solucio_ex1_text %}
        {% include code-block.html lang="java" code=solucio_ex1_code %}
    </details>

    {% include exercici.html
       nom="Refactoritza una operació JDBC"
       dificultat="Mitjana"
       temps="15 min"
       descripcio="<p>Reescriu aquest fragment JDBC utilitzant Hibernate i el patró DAO.</p>"
       pistes="Identifica on obres i tanques la connexió|Tradueix el SQL a una operació de sessió (get/merge)|Gestiona la transacció amb commit i rollback"
    %}

    {% capture code_ex2_jdbc %}
String sql = "UPDATE productes SET preu = ? WHERE id = ?";
try (Connection conn = DriverManager.getConnection(url, user, pass);
     PreparedStatement ps = conn.prepareStatement(sql)) {
    ps.setBigDecimal(1, nouPreu);
    ps.setLong(2, idProducte);
    ps.executeUpdate();
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_ex2_jdbc %}

    {% include prompt-ai.html contingut="Pregunta a l'IA com quedaria aquest canvi en un mètode del teu DAO. Dona-li el codi JDBC i demana-li que et retorni l'equivalent amb Hibernate." %}

    {% capture solucio_ex2_text %}
<p>Amb Hibernate encapsulem l'operació en un DAO i utilitzem una sessió per carregar l'entitat, modificar-la i confirmar la transacció.</p>
    {% endcapture %}
    {% capture solucio_ex2_code %}
public void actualitzaPreu(Long idProducte, BigDecimal nouPreu) {
    Transaction tx = null;
    try (Session session = sessionFactory.openSession()) {
        tx = session.beginTransaction();

        Producte producte = session.get(Producte.class, idProducte);
        producte.setPreu(nouPreu);

        session.persist(producte);
        tx.commit();
    } catch (Exception ex) {
        if (tx != null) {
            tx.rollback();
        }
        throw ex;
    }
}
    {% endcapture %}
    <details class="solution-toggle">
        <summary>Mostra la solució</summary>
        {% include solucio.html contingut=solucio_ex2_text %}
        {% include code-block.html lang="java" code=solucio_ex2_code %}
    </details>

    {% include exercici.html
       nom="Dissenya una transacció coherent"
       dificultat="Mitjana"
       temps="10 min"
       descripcio="<p>Descriu els passos que seguiries per processar una comanda: validar les línies, actualitzar estoc i enregistrar el pagament en una sola transacció.</p>"
       pistes="Recorda encapsular la lògica en un servei|Garanteix que totes les operacions comparteixen la mateixa transacció|Preveu què passa si alguna operació falla"
    %}

    {% include prompt-ai.html contingut="Demana a l'IA que et generi un esborrany de pseudocodi per a la transacció completa, indicant quan obrir i tancar la sessió." %}

    {% capture solucio_ex3_text %}
<p>Una proposta hauria d'incloure: validació de dades d'entrada, una transacció única que carregui productes, actualitzi estoc, desi la comanda i registri el pagament; si qualsevol pas falla, es fa <em>rollback</em> per deixar la base de dades consistent.</p>
<ul>
    <li>Obrir sessió i transacció al servei.</li>
    <li>Carregar productes amb <code>session.get()</code> i verificar estoc.</li>
    <li>Crear l'entitat <code>Comanda</code> i afegir línies.</li>
    <li>Persistir la comanda i registrar l'entrada de pagament.</li>
    <li>Fer <code>commit</code>; en cas d'excepció, <code>rollback</code> i informar l'usuari.</li>
</ul>
    {% endcapture %}
    <details class="solution-toggle">
        <summary>Mostra la solució</summary>
        {% include solucio.html contingut=solucio_ex3_text %}
    </details>

    {% include success_box.html contingut="Quan completis aquests exercicis tindràs les bases per abordar el tutorial del Bloc 2 amb confiança i connectar teoria i pràctica." %}
</div>
