---
layout: bloc
title: "Bloc 2: Col·leccions i tipus de dades avançats"
description: "Framework de col·leccions Java: List, Set, Map i les seves implementacions"
keywords: "Java, collections, ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap, generics"
unitat: 6
bloc: 2
bloc_numero: 2
---

<!--
  Pàgina de contingut del Bloc 2 (Unitat 6)
  Contingut sobre col·leccions i estructures de dades avançades
-->

<div class="section">
    <h2 id="Unitat6_Bloc2_Seccio1">Introducció al Framework de Col·leccions de Java</h2>
    
    <p>El Framework de Col·leccions de Java (Java Collections Framework) és un conjunt d'interfícies, classes i algorismes que proporcionen estructures de dades dinàmiques i algorismes per manipular-les de manera eficient i consistent.</p>

    <h3>Evolució: D'Arrays a Col·leccions</h3>
    
    <p>Mentre que els arrays tenen limitacions com la mida fixa, les col·leccions ofereixen flexibilitat i funcionalitat avançada:</p>

    <table class="responsive-table">
        <thead>
            <tr>
                <th>Característica</th>
                <th>Arrays</th>
                <th>Col·leccions</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Mida</strong></td>
                <td>Fixa (definida en temps de creació)</td>
                <td>Dinàmica (pot créixer/decreixe)</td>
            </tr>
            <tr>
                <td><strong>Tipus de dades</strong></td>
                <td>Primitius i objectes</td>
                <td>Només objectes (amb autoboxing)</td>
            </tr>
            <tr>
                <td><strong>Operacions</strong></td>
                <td>Bàsiques (accés per índex)</td>
                <td>Avançades (cerca, ordenació, etc.)</td>
            </tr>
            <tr>
                <td><strong>Seguretat de tipus</strong></td>
                <td>Compilació</td>
                <td>Generics (compilació + execució)</td>
            </tr>
            <tr>
                <td><strong>Rendiment</strong></td>
                <td>Molt alt per accés directe</td>
                <td>Variable segons implementació</td>
            </tr>
        </tbody>
    </table>

    <h3>Jerarquia d'Interfícies</h3>
    
    <p>El framework s'organitza al voltant de tres interfícies principals:</p>
    
    <ul>
        <li><strong>Collection:</strong> Interfície base per a grups d'objectes</li>
        <li><strong>List:</strong> Col·leccions ordenades amb elements duplicats</li>
        <li><strong>Set:</strong> Col·leccions sense elements duplicats</li>
        <li><strong>Map:</strong> Col·leccions de parells clau-valor (no hereta de Collection)</li>
    </ul>

    {% include definicio.html terme="Generics" definicio="Característica de Java que permet especificar el tipus d'objectes que pot contenir una col·lecció, proporcionant seguretat de tipus en temps de compilació." %}

    <h3>Avantatges del Framework de Col·leccions</h3>
    
    <ul>
        <li><strong>Consistència:</strong> API uniforme per a totes les col·leccions</li>
        <li><strong>Eficiència:</strong> Implementacions optimitzades per diferents casos d'ús</li>
        <li><strong>Interoperabilitat:</strong> Les col·leccions es poden combinar i convertir</li>
        <li><strong>Extensibilitat:</strong> Es poden crear implementacions personalitzades</li>
        <li><strong>Algorismes integrats:</strong> Mètodes per ordenar, cercar i manipular</li>
    </ul>

    {% include info_box.html
       contingut="<strong>Objectius d'aquest bloc:</strong><br>
       • Comprendre la jerarquia d'interfícies del framework de col·leccions<br>
       • Dominar List, Set i Map amb les seves implementacions principals<br>
       • Aplicar algorismes de cerca i ordenació amb col·leccions<br>
       • Utilitzar generics per assegurar la seguretat de tipus<br>
       • Seleccionar l'estructura adequada per a cada problema"
    %}

    {% include prompt-ai.html
       contingut="Explica'm quan hauria d'usar un Array vs ArrayList vs LinkedList en diferents escenaris. Considera factors com rendiment, operacions freqüents i mida de dades típica."
    %}
</div>

<div class="section">
    <h2 id="Unitat6_Bloc2_Seccio2">Interfície List i les seves Implementacions</h2>
    
    <p>La interfície <code>List</code> representa col·leccions ordenades (seqüències) que permeten elements duplicats. Els elements es poden accedir per índex i es mantenen en l'ordre d'inserció.</p>

    <h3>Característiques de List</h3>
    
    <ul>
        <li><strong>Indexada:</strong> Accés per posició (0, 1, 2, ...)</li>
        <li><strong>Ordenada:</strong> Manté l'ordre d'inserció</li>
        <li><strong>Duplicats:</strong> Permet elements repetits</li>
        <li><strong>Null:</strong> Accepta elements null</li>
    </ul>

    {% capture code_list_basic %}
import java.util.*;

public class ExempleList {
    public static void main(String[] args) {
        // Creació amb generics
        List<String> noms = new ArrayList<>();
        
        // Afegir elements
        noms.add("Anna");
        noms.add("Bernat");
        noms.add("Carla");
        noms.add("Anna"); // Duplicat permès
        
        // Accés per índex
        System.out.println("Primer element: " + noms.get(0));
        
        // Mida de la llista
        System.out.println("Mida: " + noms.size());
        
        // Recórrer la llista
        for (String nom : noms) {
            System.out.println("- " + nom);
        }
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_list_basic %}

    <h3>ArrayList: Implementació basada en Array Dinàmic</h3>
    
    <p><code>ArrayList</code> utilitza un array intern que es redimensiona automàticament quan cal:</p>

    {% capture code_arraylist %}
import java.util.ArrayList;

public class ExempleArrayList {
    public static void main(String[] args) {
        // Crear amb capacitat inicial (opcional)
        ArrayList<Integer> numeros = new ArrayList<>(10);
        
        // Afegir elements
        for (int i = 1; i <= 5; i++) {
            numeros.add(i * 10);
        }
        
        // Inserir en posició específica
        numeros.add(2, 25); // Insereix 25 a la posició 2
        
        // Modificar element
        numeros.set(0, 5); // Canvia el primer element a 5
        
        // Eliminar per índex
        numeros.remove(1); // Elimina l'element a la posició 1
        
        // Eliminar per valor
        numeros.remove(Integer.valueOf(25)); // Elimina el valor 25
        
        // Mostrar resultat
        System.out.println("ArrayList final: " + numeros);
        
        // Informació sobre capacitat
        System.out.println("Mida: " + numeros.size());
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_arraylist %}

    <h3>LinkedList: Implementació basada en Llista Enllaçada</h3>
    
    <p><code>LinkedList</code> utilitza nodes enllaçats, excel·lent per inserció i eliminació freqüents:</p>

    {% capture code_linkedlist %}
import java.util.LinkedList;

public class ExempleLinkedList {
    public static void main(String[] args) {
        LinkedList<String> tasques = new LinkedList<>();
        
        // Afegir al final
        tasques.add("Tasca 1");
        tasques.add("Tasca 2");
        
        // Afegir al principi
        tasques.addFirst("Tasca Urgent");
        
        // Afegir al final (equivalent a add())
        tasques.addLast("Tasca Final");
        
        // Accedir als extrems
        System.out.println("Primera: " + tasques.getFirst());
        System.out.println("Última: " + tasques.getLast());
        
        // Eliminar extrems
        String primera = tasques.removeFirst();
        String ultima = tasques.removeLast();
        
        System.out.println("Eliminades: " + primera + " i " + ultima);
        System.out.println("Tasques restants: " + tasques);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_linkedlist %}

    <h3>Comparació de Rendiment: ArrayList vs LinkedList</h3>

    <table class="responsive-table">
        <thead>
            <tr>
                <th>Operació</th>
                <th>ArrayList</th>
                <th>LinkedList</th>
                <th>Millor per</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Accés per índex</strong></td>
                <td>O(1)</td>
                <td>O(n)</td>
                <td>ArrayList</td>
            </tr>
            <tr>
                <td><strong>Inserció al final</strong></td>
                <td>O(1)*</td>
                <td>O(1)</td>
                <td>Empat</td>
            </tr>
            <tr>
                <td><strong>Inserció al principi</strong></td>
                <td>O(n)</td>
                <td>O(1)</td>
                <td>LinkedList</td>
            </tr>
            <tr>
                <td><strong>Inserció al mig</strong></td>
                <td>O(n)</td>
                <td>O(n)</td>
                <td>LinkedList (menys còpies)</td>
            </tr>
            <tr>
                <td><strong>Eliminació per índex</strong></td>
                <td>O(n)</td>
                <td>O(n)</td>
                <td>LinkedList (menys còpies)</td>
            </tr>
            <tr>
                <td><strong>Memòria per element</strong></td>
                <td>Només l'objecte</td>
                <td>Objecte + 2 referències</td>
                <td>ArrayList</td>
            </tr>
        </tbody>
    </table>

    <p><em>* O(1) amortitzat, pot ser O(n) quan cal redimensionar l'array intern</em></p>

    {% include definicio.html terme="Complexitat Amortitzada" definicio="Temps mitjà per operació calculat sobre una seqüència d'operacions. Algunes operacions poden ser costoses individualment, però el cost mitjà és baix." %}

    {% include prompt-ai.html
       contingut="Crea'm un exemple pràctic que mostri clarament quan usar ArrayList vs LinkedList. Per exemple, un sistema de gestió de cua d'impressió vs un sistema d'accés aleatori a dades."
    %}
</div>

<div class="section">
    <h2 id="Unitat6_Bloc2_Seccio3">Interfície Set i Eliminació de Duplicats</h2>
    
    <p>La interfície <code>Set</code> representa col·leccions que no permeten elements duplicats. És ideal per garantir unicitat i realitzar operacions de conjunts matemàtics.</p>

    <h3>Característiques de Set</h3>
    
    <ul>
        <li><strong>Unicitat:</strong> No permet elements duplicats</li>
        <li><strong>Mètode equals():</strong> Utilitza equals() per detectar duplicats</li>
        <li><strong>Null:</strong> Com a màxim un element null</li>
        <li><strong>Operacions de conjunt:</strong> Unió, intersecció, diferència</li>
    </ul>

    <h3>HashSet: Set basat en Taula Hash</h3>
    
    <p><code>HashSet</code> ofereix operacions O(1) mitjà, però no manté ordre:</p>

    {% capture code_hashset %}
import java.util.HashSet;
import java.util.Set;

public class ExempleHashSet {
    public static void main(String[] args) {
        Set<String> ciutats = new HashSet<>();
        
        // Afegir elements
        ciutats.add("Barcelona");
        ciutats.add("Madrid");
        ciutats.add("València");
        ciutats.add("Barcelona"); // Duplicat ignorat
        
        System.out.println("Ciutats úniques: " + ciutats.size()); // 3
        System.out.println("Contingut: " + ciutats);
        
        // Comprovar existència
        if (ciutats.contains("Barcelona")) {
            System.out.println("Barcelona està al conjunt");
        }
        
        // Eliminar duplicats d'una llista
        eliminarDuplicats();
    }
    
    public static void eliminarDuplicats() {
        // Llista amb duplicats
        List<Integer> llistaAmbDuplicats = Arrays.asList(1, 2, 2, 3, 4, 3, 5);
        
        // Eliminar duplicats
        Set<Integer> setSenseRepeticions = new HashSet<>(llistaAmbDuplicats);
        List<Integer> llistaSenseDuplicats = new ArrayList<>(setSenseRepeticions);
        
        System.out.println("Original: " + llistaAmbDuplicats);
        System.out.println("Sense duplicats: " + llistaSenseDuplicats);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_hashset %}

    <h3>TreeSet: Set Ordenat</h3>
    
    <p><code>TreeSet</code> manté els elements ordenats utilitzant un arbre binari balancejat:</p>

    {% capture code_treeset %}
import java.util.TreeSet;

public class ExempleTreeSet {
    public static void main(String[] args) {
        TreeSet<Integer> numerosOrdenats = new TreeSet<>();
        
        // Afegir elements desordenats
        numerosOrdenats.add(50);
        numerosOrdenats.add(20);
        numerosOrdenats.add(80);
        numerosOrdenats.add(10);
        numerosOrdenats.add(30);
        
        System.out.println("Elements ordenats: " + numerosOrdenats);
        
        // Operacions específiques de TreeSet
        System.out.println("Primer element: " + numerosOrdenats.first());
        System.out.println("Últim element: " + numerosOrdenats.last());
        
        // Subconjunts
        System.out.println("Menors que 40: " + numerosOrdenats.headSet(40));
        System.out.println("Majors o iguals a 30: " + numerosOrdenats.tailSet(30));
        System.out.println("Entre 20 i 60: " + numerosOrdenats.subSet(20, 60));
        
        // Elements més propers
        System.out.println("Menor o igual a 45: " + numerosOrdenats.floor(45)); // 30
        System.out.println("Major a 45: " + numerosOrdenats.higher(45)); // 50
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_treeset %}

    <h3>Operacions de Conjunts</h3>
    
    {% capture code_set_operations %}
import java.util.*;

public class OperacionsConjunts {
    public static void main(String[] args) {
        Set<String> conjuntA = new HashSet<>(Arrays.asList("A", "B", "C", "D"));
        Set<String> conjuntB = new HashSet<>(Arrays.asList("C", "D", "E", "F"));
        
        // Unió (A ∪ B)
        Set<String> unio = new HashSet<>(conjuntA);
        unio.addAll(conjuntB);
        System.out.println("Unió: " + unio);
        
        // Intersecció (A ∩ B)
        Set<String> interseccio = new HashSet<>(conjuntA);
        interseccio.retainAll(conjuntB);
        System.out.println("Intersecció: " + interseccio);
        
        // Diferència (A - B)
        Set<String> diferencia = new HashSet<>(conjuntA);
        diferencia.removeAll(conjuntB);
        System.out.println("Diferència A-B: " + diferencia);
        
        // Diferència simètrica (A △ B)
        Set<String> diferenciaSimetrica = new HashSet<>(unio);
        diferenciaSimetrica.removeAll(interseccio);
        System.out.println("Diferència simètrica: " + diferenciaSimetrica);
        
        // Verificar si un conjunt és subconjunt d'un altre
        Set<String> subconjunt = new HashSet<>(Arrays.asList("A", "B"));
        boolean esSubconjunt = conjuntA.containsAll(subconjunt);
        System.out.println("És subconjunt: " + esSubconjunt);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_set_operations %}

    {% include definicio.html terme="Taula Hash" definicio="Estructura de dades que utilitza una funció hash per mapejar claus a posicions, oferint accés O(1) mitjà per a operacions de cerca, inserció i eliminació." %}

    {% include warning_box.html
       contingut="<strong>Important:</strong> Per utilitzar objectes personalitzats en HashSet, cal implementar correctament els mètodes <code>equals()</code> i <code>hashCode()</code>. Si no, els duplicats no es detectaran adequadament."
    %}

    {% include prompt-ai.html
       contingut="Explica'm com implementar equals() i hashCode() per una classe Persona (nom, dni) per poder usar-la correctament en HashSet. També vull entendre què passa si només implemento un dels dos mètodes."
    %}
</div>

<div class="section">
    <h2 id="Unitat6_Bloc2_Seccio4">Interfície Map i Estructures Clau-Valor</h2>
    
    <p>La interfície <code>Map</code> representa col·leccions de parells clau-valor, on cada clau és única i s'associa amb un valor. És similar a un diccionari o taula de consulta.</p>

    <h3>Característiques de Map</h3>
    
    <ul>
        <li><strong>Claus úniques:</strong> Cada clau apareix com a màxim una vegada</li>
        <li><strong>Associació clau-valor:</strong> Cada clau té un valor associat</li>
        <li><strong>Null:</strong> Pot acceptar clau null i valors null (depenent de la implementació)</li>
        <li><strong>No hereta de Collection:</strong> Té la seva pròpia jerarquia</li>
    </ul>

    <h3>HashMap: Map basat en Taula Hash</h3>
    
    <p><code>HashMap</code> ofereix operacions O(1) mitjà però no garanteix ordre:</p>

    {% capture code_hashmap %}
import java.util.HashMap;
import java.util.Map;

public class ExempleHashMap {
    public static void main(String[] args) {
        // Crear un diccionari de traduccions
        Map<String, String> traduccions = new HashMap<>();
        
        // Afegir parells clau-valor
        traduccions.put("hello", "hola");
        traduccions.put("world", "món");
        traduccions.put("computer", "ordinador");
        traduccions.put("programming", "programació");
        
        // Accedir a valors per clau
        String traduccio = traduccions.get("hello");
        System.out.println("hello -> " + traduccio);
        
        // Verificar existència
        if (traduccions.containsKey("world")) {
            System.out.println("La clau 'world' existeix");
        }
        
        if (traduccions.containsValue("ordinador")) {
            System.out.println("El valor 'ordinador' existeix");
        }
        
        // Recórrer el map
        System.out.println("\nTotes les traduccions:");
        for (Map.Entry<String, String> entrada : traduccions.entrySet()) {
            System.out.println(entrada.getKey() + " -> " + entrada.getValue());
        }
        
        // Alternatives de recorregut
        System.out.println("\nNomés claus:");
        for (String clau : traduccions.keySet()) {
            System.out.println("- " + clau);
        }
        
        System.out.println("\nNomés valors:");
        for (String valor : traduccions.values()) {
            System.out.println("- " + valor);
        }
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_hashmap %}

    <h3>TreeMap: Map Ordenat per Claus</h3>
    
    <p><code>TreeMap</code> manté les claus ordenades utilitzant un arbre binari balancejat:</p>

    {% capture code_treemap %}
import java.util.TreeMap;

public class ExempleTreeMap {
    public static void main(String[] args) {
        // Comptador de paraules ordenat alfabèticament
        TreeMap<String, Integer> comptadorParaules = new TreeMap<>();
        
        String[] paraules = {"gat", "gos", "au", "peix", "gat", "au", "gat"};
        
        // Comptar freqüència de paraules
        for (String paraula : paraules) {
            comptadorParaules.put(paraula, 
                comptadorParaules.getOrDefault(paraula, 0) + 1);
        }
        
        System.out.println("Freqüència de paraules (ordenat):");
        comptadorParaules.forEach((paraula, freq) -> 
            System.out.println(paraula + ": " + freq + " vegades"));
        
        // Operacions específiques de TreeMap
        System.out.println("\nPrimera clau: " + comptadorParaules.firstKey());
        System.out.println("Última clau: " + comptadorParaules.lastKey());
        
        // Subconjunts de claus
        System.out.println("Claus fins 'gos': " + comptadorParaules.headMap("gos"));
        System.out.println("Claus des de 'gat': " + comptadorParaules.tailMap("gat"));
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_treemap %}

    <h3>Exemple Pràctic: Sistema de Gestió d'Estudiants</h3>
    
    {% capture code_students_system %}
import java.util.*;

class Estudiant {
    private String nom;
    private int edat;
    private double nota;
    
    public Estudiant(String nom, int edat, double nota) {
        this.nom = nom;
        this.edat = edat;
        this.nota = nota;
    }
    
    // Getters
    public String getNom() { return nom; }
    public int getEdat() { return edat; }
    public double getNota() { return nota; }
    
    @Override
    public String toString() {
        return String.format("%s (%d anys, nota: %.1f)", nom, edat, nota);
    }
}

public class SistemaEstudiants {
    public static void main(String[] args) {
        // Map principal: DNI -> Estudiant
        Map<String, Estudiant> estudiants = new HashMap<>();
        
        // Afegir estudiants
        estudiants.put("12345678A", new Estudiant("Anna Martí", 20, 8.5));
        estudiants.put("87654321B", new Estudiant("Bernat Soler", 19, 7.2));
        estudiants.put("11111111C", new Estudiant("Carla Vidal", 21, 9.1));
        estudiants.put("22222222D", new Estudiant("David Font", 20, 6.8));
        
        // Buscar per DNI
        String dniCercat = "12345678A";
        Estudiant trobat = estudiants.get(dniCercat);
        if (trobat != null) {
            System.out.println("Estudiant trobat: " + trobat);
        }
        
        // Crear índex per edat
        Map<Integer, List<Estudiant>> perEdat = new HashMap<>();
        for (Estudiant est : estudiants.values()) {
            perEdat.computeIfAbsent(est.getEdat(), k -> new ArrayList<>()).add(est);
        }
        
        System.out.println("\nEstudiants de 20 anys:");
        List<Estudiant> estudiants20 = perEdat.get(20);
        if (estudiants20 != null) {
            estudiants20.forEach(System.out::println);
        }
        
        // Estadístiques
        calcularEstadistiques(estudiants.values());
    }
    
    public static void calcularEstadistiques(Collection<Estudiant> estudiants) {
        if (estudiants.isEmpty()) return;
        
        double sumaEdat = 0, sumaNota = 0;
        double maxNota = Double.MIN_VALUE;
        double minNota = Double.MAX_VALUE;
        
        for (Estudiant est : estudiants) {
            sumaEdat += est.getEdat();
            sumaNota += est.getNota();
            maxNota = Math.max(maxNota, est.getNota());
            minNota = Math.min(minNota, est.getNota());
        }
        
        int total = estudiants.size();
        System.out.println("\n=== ESTADÍSTIQUES ===");
        System.out.printf("Total estudiants: %d%n", total);
        System.out.printf("Edat mitjana: %.1f anys%n", sumaEdat / total);
        System.out.printf("Nota mitjana: %.2f%n", sumaNota / total);
        System.out.printf("Millor nota: %.1f%n", maxNota);
        System.out.printf("Pitjor nota: %.1f%n", minNota);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_students_system %}

    <h3>Comparació de Implementacions de Map</h3>

    <table class="responsive-table">
        <thead>
            <tr>
                <th>Implementació</th>
                <th>Ordre</th>
                <th>Complexitat (get/put)</th>
                <th>Null</th>
                <th>Millor ús</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>HashMap</strong></td>
                <td>No garanteix</td>
                <td>O(1) mitjà</td>
                <td>Una clau null, valors null</td>
                <td>Rendiment general</td>
            </tr>
            <tr>
                <td><strong>TreeMap</strong></td>
                <td>Claus ordenades</td>
                <td>O(log n)</td>
                <td>No clau null, valors null</td>
                <td>Claus ordenades</td>
            </tr>
            <tr>
                <td><strong>LinkedHashMap</strong></td>
                <td>Inserció o accés</td>
                <td>O(1) mitjà</td>
                <td>Una clau null, valors null</td>
                <td>Ordre d'inserció</td>
            </tr>
        </tbody>
    </table>

    {% include definicio.html terme="computeIfAbsent" definicio="Mètode de Map que només calcula i insereix un valor si la clau no existeix, útil per inicialitzar col·leccions dins de maps." %}

    {% include prompt-ai.html
       contingut="Implementa un sistema de cau (cache) LRU (Least Recently Used) utilitzant LinkedHashMap. El cache ha de tenir una mida màxima i eliminar automàticament l'element menys recentment utilitzat quan es supera la capacitat."
    %}
</div>

<div class="section">
    <h2 id="Unitat6_Bloc2_Seccio5">Algorismes i Utilitats per a Col·leccions</h2>
    
    <p>Java proporciona la classe <code>Collections</code> amb mètodes estàtics per manipular col·leccions, i els streams per processar dades de manera funcional.</p>

    <h3>Classe Collections: Algorismes Integrats</h3>
    
    {% capture code_collections_utils %}
import java.util.*;

public class UtilitatsCollections {
    public static void main(String[] args) {
        List<Integer> numeros = new ArrayList<>(Arrays.asList(5, 2, 8, 1, 9, 3));
        System.out.println("Llista original: " + numeros);
        
        // Ordenació
        Collections.sort(numeros);
        System.out.println("Ordenada: " + numeros);
        
        // Barrejar (shuffle)
        Collections.shuffle(numeros);
        System.out.println("Barrejada: " + numeros);
        
        // Revertir
        Collections.reverse(numeros);
        System.out.println("Revertida: " + numeros);
        
        // Cerca binària (requereix llista ordenada)
        Collections.sort(numeros);
        int posicio = Collections.binarySearch(numeros, 5);
        System.out.println("Posició del 5: " + posicio);
        
        // Màxim i mínim
        int max = Collections.max(numeros);
        int min = Collections.min(numeros);
        System.out.printf("Màxim: %d, Mínim: %d%n", max, min);
        
        // Freqüència d'un element
        List<String> lletres = Arrays.asList("a", "b", "a", "c", "a", "b");
        int freqA = Collections.frequency(lletres, "a");
        System.out.println("Freqüència de 'a': " + freqA);
        
        // Emplenar amb un valor
        List<String> llista = new ArrayList<>(Arrays.asList("x", "y", "z"));
        Collections.fill(llista, "0");
        System.out.println("Emplenada: " + llista);
        
        // Rotació
        List<Integer> nums = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        Collections.rotate(nums, 2);
        System.out.println("Rotada 2 posicions: " + nums);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_collections_utils %}

    <h3>Ordenació Personalitzada amb Comparator</h3>
    
    {% capture code_custom_sorting %}
import java.util.*;

class Persona {
    String nom;
    int edat;
    
    public Persona(String nom, int edat) {
        this.nom = nom;
        this.edat = edat;
    }
    
    @Override
    public String toString() {
        return nom + " (" + edat + ")";
    }
}

public class OrdenacioPersonalitzada {
    public static void main(String[] args) {
        List<Persona> persones = Arrays.asList(
            new Persona("Anna", 25),
            new Persona("Bernat", 30),
            new Persona("Carla", 20),
            new Persona("David", 35)
        );
        
        System.out.println("Original: " + persones);
        
        // Ordenar per edat (ascendent)
        persones.sort(Comparator.comparing(p -> p.edat));
        System.out.println("Per edat: " + persones);
        
        // Ordenar per nom (alfabètic)
        persones.sort(Comparator.comparing(p -> p.nom));
        System.out.println("Per nom: " + persones);
        
        // Ordenar per edat (descendent)
        persones.sort(Comparator.comparing((Persona p) -> p.edat).reversed());
        System.out.println("Per edat (desc): " + persones);
        
        // Ordenació múltiple: primer per edat, després per nom
        List<Persona> mes = Arrays.asList(
            new Persona("Anna", 25), new Persona("Bernat", 25),
            new Persona("Carla", 30), new Persona("Anna", 20)
        );
        
        mes.sort(Comparator.comparing((Persona p) -> p.edat)
                          .thenComparing(p -> p.nom));
        System.out.println("Múltiple: " + mes);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_custom_sorting %}

    <h3>Introducció a Streams</h3>
    
    <p>Els streams permeten processar col·leccions de manera funcional i declarativa:</p>
    
    {% capture code_streams_intro %}
import java.util.*;
import java.util.stream.Collectors;

public class IntroduccioStreams {
    public static void main(String[] args) {
        List<String> noms = Arrays.asList(
            "Anna", "Bernat", "Carla", "David", "Elena", "Ferran"
        );
        
        // Filtrar noms que comencen per 'A' o 'E'
        List<String> filtrats = noms.stream()
            .filter(nom -> nom.startsWith("A") || nom.startsWith("E"))
            .collect(Collectors.toList());
        System.out.println("Noms amb A o E: " + filtrats);
        
        // Convertir a majúscules
        List<String> majuscules = noms.stream()
            .map(String::toUpperCase)
            .collect(Collectors.toList());
        System.out.println("Majúscules: " + majuscules);
        
        // Comptar noms amb més de 5 caràcters
        long nomsCurts = noms.stream()
            .filter(nom -> nom.length() > 5)
            .count();
        System.out.println("Noms amb més de 5 caràcters: " + nomsCurts);
        
        // Trobar el nom més llarg
        Optional<String> mesLlarg = noms.stream()
            .max(Comparator.comparing(String::length));
        mesLlarg.ifPresent(nom -> System.out.println("Nom més llarg: " + nom));
        
        // Exemple amb números
        List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // Suma de quadrats de números parells
        int sumaQuadrats = numeros.stream()
            .filter(n -> n % 2 == 0)        // Filtrar parells
            .mapToInt(n -> n * n)           // Elevar al quadrat
            .sum();                         // Sumar tot
        System.out.println("Suma de quadrats de parells: " + sumaQuadrats);
        
        // Agrupar noms per longitud
        Map<Integer, List<String>> perLongitud = noms.stream()
            .collect(Collectors.groupingBy(String::length));
        System.out.println("Agrupats per longitud: " + perLongitud);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_streams_intro %}

    <h3>Rendiment: Quan Usar Streams vs Bucles Tradicionals</h3>

    <table class="responsive-table">
        <thead>
            <tr>
                <th>Criteri</th>
                <th>Bucles Tradicionals</th>
                <th>Streams</th>
                <th>Recomanació</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Rendiment</strong></td>
                <td>Més ràpid per operacions simples</td>
                <td>Overhead per col·leccions petites</td>
                <td>Bucles per &lt;100 elements</td>
            </tr>
            <tr>
                <td><strong>Llegibilitat</strong></td>
                <td>Verbosos per lògica complexa</td>
                <td>Declaratius i expressius</td>
                <td>Streams per lògica complexa</td>
            </tr>
            <tr>
                <td><strong>Paral·lelització</strong></td>
                <td>Manual i propensa a errors</td>
                <td>parallelStream() automàtic</td>
                <td>Streams per paral·lelisme</td>
            </tr>
            <tr>
                <td><strong>Operacions múltiples</strong></td>
                <td>Múltiples iteracions</td>
                <td>Una sola passada</td>
                <td>Streams per operacions encadenades</td>
            </tr>
            <tr>
                <td><strong>Debugging</strong></td>
                <td>Més fàcil amb breakpoints</td>
                <td>Més difícil de depurar</td>
                <td>Bucles per debugging intensiu</td>
            </tr>
        </tbody>
    </table>

    {% include info_box.html
       contingut="<strong>Consells per a streams:</strong><br>
       • Usa streams per operacions de transformació i filtratge<br>
       • Evita efectes secundaris dins de lambda expressions<br>
       • Considera parallelStream() per col·leccions grans (>10.000 elements)<br>
       • Utilitza mètodes específics com mapToInt() per evitar boxing<br>
       • Sempre tanca streams que treballen amb recursos externs"
    %}

    {% include prompt-ai.html
       contingut="Crea'm un exemple avançat que combini Map, Set i List per gestionar un sistema de biblioteca: llibres amb categories, autors i disponibilitat. Inclou operacions com buscar per categoria, autors més prolífics i llibres disponibles."
    %}
</div>

<div class="section">
    <h2 id="Unitat6_Bloc2_Seccio6">Rendiment i Selecció d'Estructures</h2>
    
    <p>La selecció adequada de l'estructura de dades és crucial per al rendiment de l'aplicació. Aquest apartat proporciona guies pràctiques per triar la col·lecció òptima.</p>

    <h3>Matriu de Decisió per Col·leccions</h3>

    <table class="responsive-table">
        <thead>
            <tr>
                <th>Necessitats</th>
                <th>Col·lecció Recomanada</th>
                <th>Alternativa</th>
                <th>Evitar</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Accés aleatori ràpid + mida variable</td>
                <td><code>ArrayList</code></td>
                <td><code>Array</code> (mida fixa)</td>
                <td><code>LinkedList</code></td>
            </tr>
            <tr>
                <td>Inserció/eliminació freqüent</td>
                <td><code>LinkedList</code></td>
                <td><code>ArrayDeque</code></td>
                <td><code>ArrayList</code></td>
            </tr>
            <tr>
                <td>Elements únics sense ordre</td>
                <td><code>HashSet</code></td>
                <td><code>LinkedHashSet</code></td>
                <td><code>TreeSet</code></td>
            </tr>
            <tr>
                <td>Elements únics ordenats</td>
                <td><code>TreeSet</code></td>
                <td><code>LinkedHashSet + sort</code></td>
                <td><code>HashSet</code></td>
            </tr>
            <tr>
                <td>Diccionari ràpid</td>
                <td><code>HashMap</code></td>
                <td><code>LinkedHashMap</code></td>
                <td><code>TreeMap</code></td>
            </tr>
            <tr>
                <td>Diccionari ordenat</td>
                <td><code>TreeMap</code></td>
                <td><code>LinkedHashMap</code></td>
                <td><code>HashMap</code></td>
            </tr>
            <tr>
                <td>Pila (LIFO)</td>
                <td><code>ArrayDeque</code></td>
                <td><code>Stack</code></td>
                <td><code>ArrayList</code></td>
            </tr>
            <tr>
                <td>Cua (FIFO)</td>
                <td><code>ArrayDeque</code></td>
                <td><code>LinkedList</code></td>
                <td><code>ArrayList</code></td>
            </tr>
        </tbody>
    </table>

    <h3>Test de Rendiment Pràctic</h3>
    
    {% capture code_performance_test %}
import java.util.*;

public class TestRendiment {
    private static final int N = 100_000;
    
    public static void main(String[] args) {
        System.out.println("Test de rendiment amb " + N + " elements\n");
        
        testList();
        testSet();
        testMap();
    }
    
    public static void testList() {
        System.out.println("=== TEST LLISTES ===");
        
        // ArrayList vs LinkedList per inserció al principi
        testInsertAtBeginning();
        
        // ArrayList vs LinkedList per accés aleatori
        testRandomAccess();
    }
    
    private static void testInsertAtBeginning() {
        // ArrayList
        long start = System.currentTimeMillis();
        List<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            arrayList.add(0, i); // Inserir al principi
        }
        long arrayListTime = System.currentTimeMillis() - start;
        
        // LinkedList
        start = System.currentTimeMillis();
        List<Integer> linkedList = new LinkedList<>();
        for (int i = 0; i < N; i++) {
            linkedList.add(0, i); // Inserir al principi
        }
        long linkedListTime = System.currentTimeMillis() - start;
        
        System.out.printf("Inserció al principi:%n");
        System.out.printf("  ArrayList: %d ms%n", arrayListTime);
        System.out.printf("  LinkedList: %d ms%n", linkedListTime);
        System.out.printf("  LinkedList és %.1fx més ràpida%n%n", 
                         (double)arrayListTime / linkedListTime);
    }
    
    private static void testRandomAccess() {
        // Preparar dades
        List<Integer> arrayList = new ArrayList<>();
        List<Integer> linkedList = new LinkedList<>();
        
        for (int i = 0; i < N; i++) {
            arrayList.add(i);
            linkedList.add(i);
        }
        
        Random random = new Random();
        
        // ArrayList - accés aleatori
        long start = System.currentTimeMillis();
        for (int i = 0; i < N; i++) {
            int index = random.nextInt(N);
            arrayList.get(index);
        }
        long arrayListTime = System.currentTimeMillis() - start;
        
        // LinkedList - accés aleatori
        start = System.currentTimeMillis();
        for (int i = 0; i < N; i++) {
            int index = random.nextInt(N);
            linkedList.get(index);
        }
        long linkedListTime = System.currentTimeMillis() - start;
        
        System.out.printf("Accés aleatori:%n");
        System.out.printf("  ArrayList: %d ms%n", arrayListTime);
        System.out.printf("  LinkedList: %d ms%n", linkedListTime);
        System.out.printf("  ArrayList és %.1fx més ràpida%n%n", 
                         (double)linkedListTime / arrayListTime);
    }
    
    public static void testSet() {
        System.out.println("=== TEST SETS ===");
        
        Set<Integer> hashSet = new HashSet<>();
        Set<Integer> treeSet = new TreeSet<>();
        
        // Test d'inserció
        long start = System.currentTimeMillis();
        for (int i = 0; i < N; i++) {
            hashSet.add(i);
        }
        long hashSetTime = System.currentTimeMillis() - start;
        
        start = System.currentTimeMillis();
        for (int i = 0; i < N; i++) {
            treeSet.add(i);
        }
        long treeSetTime = System.currentTimeMillis() - start;
        
        System.out.printf("Inserció en Set:%n");
        System.out.printf("  HashSet: %d ms%n", hashSetTime);
        System.out.printf("  TreeSet: %d ms%n", treeSetTime);
        System.out.printf("  HashSet és %.1fx més ràpid%n%n", 
                         (double)treeSetTime / hashSetTime);
    }
    
    public static void testMap() {
        System.out.println("=== TEST MAPS ===");
        
        Map<Integer, String> hashMap = new HashMap<>();
        Map<Integer, String> treeMap = new TreeMap<>();
        
        // Test de put
        long start = System.currentTimeMillis();
        for (int i = 0; i < N; i++) {
            hashMap.put(i, "valor" + i);
        }
        long hashMapTime = System.currentTimeMillis() - start;
        
        start = System.currentTimeMillis();
        for (int i = 0; i < N; i++) {
            treeMap.put(i, "valor" + i);
        }
        long treeMapTime = System.currentTimeMillis() - start;
        
        System.out.printf("Inserció en Map:%n");
        System.out.printf("  HashMap: %d ms%n", hashMapTime);
        System.out.printf("  TreeMap: %d ms%n", treeMapTime);
        System.out.printf("  HashMap és %.1fx més ràpid%n", 
                         (double)treeMapTime / hashMapTime);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_performance_test %}

    <h3>Bones Pràctiques per al Rendiment</h3>
    
    <ul>
        <li><strong>Capacitat inicial:</strong> Especifica la capacitat inicial per HashMap i ArrayList si coneixes la mida aproximada</li>
        <li><strong>Load factor:</strong> Ajusta el factor de càrrega per HashSet i HashMap segons el teu cas d'ús</li>
        <li><strong>Immutabilitat:</strong> Usa col·leccions immutables quan sigui possible per evitar còpies defensives</li>
        <li><strong>Iteració:</strong> Utilitza enhanced for loop o streams en lloc d'iteradors manuals</li>
        <li><strong>Eliminació:</strong> Usa iterator.remove() per eliminar elements durant la iteració</li>
    </ul>

    {% capture code_best_practices %}
import java.util.*;

public class BonesPractiques {
    public static void main(String[] args) {
        // 1. Capacitat inicial
        List<String> llistaGran = new ArrayList<>(10000); // Evita redimensionaments
        Map<String, Integer> mapGran = new HashMap<>(1000, 0.8f); // Custom load factor
        
        // 2. Eliminació segura durant iteració
        List<Integer> numeros = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        
        // MAL: ConcurrentModificationException
        // for (Integer num : numeros) {
        //     if (num % 2 == 0) numeros.remove(num); // ERROR!
        // }
        
        // BÉ: Usar iterator
        Iterator<Integer> it = numeros.iterator();
        while (it.hasNext()) {
            if (it.next() % 2 == 0) {
                it.remove(); // Segur
            }
        }
        System.out.println("Després d'eliminar parells: " + numeros);
        
        // 3. Col·leccions immutables (Java 9+)
        List<String> immutable = List.of("a", "b", "c");
        Set<Integer> setImmutable = Set.of(1, 2, 3);
        Map<String, Integer> mapImmutable = Map.of("un", 1, "dos", 2);
        
        // 4. Comparació eficient per ordenació
        List<String> paraules = Arrays.asList("zebra", "ànec", "gat", "elefant");
        
        // Ordenació natural (alfabètica)
        Collections.sort(paraules);
        
        // Ordenació per longitud (custom)
        paraules.sort(Comparator.comparing(String::length));
        
        System.out.println("Ordenades per longitud: " + paraules);
        
        // 5. Conversió eficient entre col·leccions
        Set<String> set = new HashSet<>(Arrays.asList("a", "b", "a", "c"));
        List<String> llistaSenseDuplicats = new ArrayList<>(set);
        
        System.out.println("Sense duplicats: " + llistaSenseDuplicats);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_best_practices %}

    {% include warning_box.html
       contingut="<strong>Errors comuns:</strong><br>
       • Modificar col·leccions durant iteració sense usar Iterator.remove()<br>
       • Usar TreeSet/TreeMap sense necessitat d'ordre<br>
       • No especificar capacitat inicial per col·leccions grans<br>
       • Comparar objectes sense implementar equals() i hashCode()<br>
       • Usar LinkedList per accés aleatori freqüent"
    %}

    {% include prompt-ai.html
       contingut="Dissenya un benchmark complet per comparar ArrayList vs LinkedList vs ArrayDeque en diferents escenaris: inserció al principi/final/mig, eliminació i accés aleatori. Vull entendre quan cada estructura és òptima."
    %}
</div>

<div class="section">
    <h2 id="Unitat6_Bloc2_Seccio7">Exercicis Pràctics</h2>
    
    <p>Per consolidar els coneixements sobre col·leccions, es proposen els següents exercicis graduats per dificultat:</p>

    {% include exercici.html 
       nom="Gestió de Llista de Compra"
       dificultat="Fàcil"
       temps="20 min"
       descripcio="<p>Crea un programa que gestioni una llista de compra utilitzant ArrayList. Ha de permetre afegir productes, eliminar-los, comprovar si un producte està a la llista i mostrar tots els productes ordenats alfabèticament.</p>"
    %}

    {% include exercici.html 
       nom="Comptador de Paraules"
       dificultat="Fàcil"
       temps="25 min"
       descripcio="<p>Implementa un programa que llegeixi un text i compti la freqüència de cada paraula utilitzant HashMap. Mostra les paraules ordenades per freqüència (de més a menys freqüent).</p>"
    %}

    {% include exercici.html 
       nom="Eliminació de Duplicats"
       dificultat="Mitjà"
       temps="30 min"
       descripcio="<p>Escriu un programa que llegeixi una llista de números enters i elimini els duplicats mantenint l'ordre original. Compara l'eficiència d'usar HashSet vs LinkedHashSet per aquesta tasca.</p>"
    %}

    {% include exercici.html 
       nom="Sistema d'Inventari"
       dificultat="Mitjà"
       temps="40 min"
       descripcio="<p>Desenvolupa un sistema d'inventari per una botiga que utilitzi Map per emmagatzemar productes (codi -> Producte) i Set per categories. Inclou operacions de cerca per categoria i actualització d'estoc.</p>"
    %}

    {% include exercici.html 
       nom="Anàlisi de Xarxes Socials"
       dificultat="Avançat"
       temps="50 min"
       descripcio="<p>Crea un sistema que modelitzi una xarxa social simple utilitzant Map&lt;Usuari, Set&lt;Usuari&gt;&gt; per representar amistats. Implementa funcions per trobar amics comuns, suggerir amistats i calcular el grau de separació entre usuaris.</p>"
    %}

    {% include exercici.html 
       nom="Cache LRU amb LinkedHashMap"
       dificultat="Avançat"
       temps="45 min"
       descripcio="<p>Implementa un cache LRU (Least Recently Used) utilitzant LinkedHashMap. El cache ha de tenir una capacitat màxima i eliminar automàticament l'element menys recentment utilitzat quan es supera. Inclou mètriques de hit/miss rate.</p>"
    %}

    {% include exercici.html 
       nom="Comparador Multi-criteri"
       dificultat="Avançat"
       temps="35 min"
       descripcio="<p>Crea una classe Empleat amb nom, departament, salari i antiguitat. Implementa diferents estratègies d'ordenació utilitzant Comparator: per salari (desc), per departament i salari, i per antiguitat amb desempat per nom.</p>"
    %}

    {% include prompt-ai.html
       contingut="Per l'exercici d'anàlisi de xarxes socials: com puc implementar un algorisme eficient per trobar el camí més curt entre dos usuaris? Vull entendre tant BFS com si hi ha alternatives més optimitzades."
    %}
</div>