---
layout: bloc
title: "Bloc 2: Caracter√≠stiques avan√ßades i abstracci√≥"
description: "Classes abstractes, interf√≠cies, principis SOLID i patrons de disseny orientats a objectes"
keywords: "Java, classes abstractes, interf√≠cies, SOLID, patrons disseny, abstracci√≥"
unitat: 7
bloc: 2
bloc_numero: 2
---

<!--
  P√†gina de contingut del Bloc 2 (Unitat 7)
  Contingut sobre caracter√≠stiques avan√ßades de POO i abstracci√≥
-->

<div class="section">
    <h2 id="Unitat7_Bloc2_Seccio1">Classes Abstractes</h2>
    
    <p>Una <strong>classe abstracta</strong> √©s una classe que no es pot instanciar directament i que est√† dissenyada per ser heretada per altres classes. Pot contenir m√®todes concrets i m√®todes abstractes.</p>

    {% include definicio.html terme="Classe Abstracta" definicio="Classe que no pot ser instanciada i que cont√© un o m√©s m√®todes abstractes. Serveix com a plantilla per a subclasses que han d'implementar els m√®todes abstractes." %}

    {% include info_box.html
       contingut="Caracter√≠stiques de les classes abstractes:<br>
       ‚Ä¢ Utilitzen la paraula clau <code>abstract</code><br>
       ‚Ä¢ No es poden instanciar amb <code>new</code><br>
       ‚Ä¢ Poden tenir m√®todes concrets i abstractes<br>
       ‚Ä¢ Poden tenir constructors, atributs i m√®todes est√†tics<br>
       ‚Ä¢ Les subclasses han d'implementar tots els m√®todes abstractes"
    %}

    <h3>Sintaxi i Exemple B√†sic</h3>
    
    {% capture code_classe_abstracta %}
// Classe abstracta base
public abstract class Figura {
    protected String nom;
    protected String color;
    
    // Constructor (les classes abstractes poden tenir constructors)
    public Figura(String nom, String color) {
        this.nom = nom;
        this.color = color;
    }
    
    // M√®todes concrets (implementaci√≥ proporcionada)
    public String getNom() {
        return nom;
    }
    
    public String getColor() {
        return color;
    }
    
    public void mostrarInfo() {
        System.out.println("Figura: " + nom + " de color " + color);
    }
    
    // M√®todes abstractes (han de ser implementats per les subclasses)
    public abstract double calcularArea();
    public abstract double calcularPerimetre();
    public abstract void dibuixar();
}

// Subclasse concreta que implementa tots els m√®todes abstractes
public class Quadrat extends Figura {
    private double costat;
    
    public Quadrat(String color, double costat) {
        super("Quadrat", color); // Cridar constructor de la classe abstracta
        this.costat = costat;
    }
    
    @Override
    public double calcularArea() {
        return costat * costat;
    }
    
    @Override
    public double calcularPerimetre() {
        return 4 * costat;
    }
    
    @Override
    public void dibuixar() {
        System.out.println("Dibuixant un quadrat de " + costat + " unitats");
    }
    
    // M√®tode espec√≠fic de Quadrat
    public double getCostat() {
        return costat;
    }
}

public class Triangle extends Figura {
    private double base, altura, costat1, costat2;
    
    public Triangle(String color, double base, double altura, double costat1, double costat2) {
        super("Triangle", color);
        this.base = base;
        this.altura = altura;
        this.costat1 = costat1;
        this.costat2 = costat2;
    }
    
    @Override
    public double calcularArea() {
        return (base * altura) / 2.0;
    }
    
    @Override
    public double calcularPerimetre() {
        return base + costat1 + costat2;
    }
    
    @Override
    public void dibuixar() {
        System.out.println("Dibuixant un triangle amb base " + base + " i altura " + altura);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_classe_abstracta %}

    <h3>Exemple d'√ös de Classes Abstractes</h3>
    
    {% capture code_us_abstract %}
public class ExempleClassesAbstractes {
    public static void main(String[] args) {
        // Error de compilaci√≥: no es pot instanciar una classe abstracta
        // Figura figura = new Figura("Test", "Blau"); // ‚ùå No funciona
        
        // Crear inst√†ncies de subclasses concretes
        Figura quadrat = new Quadrat("Vermell", 5.0);
        Figura triangle = new Triangle("Blau", 6.0, 4.0, 3.0, 5.0);
        
        // Array polim√≤rfic amb figures
        Figura[] figures = {quadrat, triangle};
        
        System.out.println("=== Informaci√≥ de les figures ===");
        for (Figura figura : figures) {
            figura.mostrarInfo();
            figura.dibuixar();
            System.out.printf("√Ärea: %.2f, Per√≠metre: %.2f%n", 
                             figura.calcularArea(), figura.calcularPerimetre());
            System.out.println("---");
        }
        
        // Processar figures de manera polim√≤rfica
        double areaTotal = calcularAreaTotal(figures);
        System.out.printf("√Ärea total de totes les figures: %.2f%n", areaTotal);
    }
    
    // M√®tode que treballa amb classes abstractes polim√≤rficament
    public static double calcularAreaTotal(Figura[] figures) {
        double total = 0;
        for (Figura figura : figures) {
            total += figura.calcularArea(); // Polimorfisme
        }
        return total;
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_us_abstract %}

    {% include prompt-ai.html
       contingut="Puc implementar m√®todes en una interf√≠cie? Quina √©s la difer√®ncia amb els m√®todes per defecte?"
    %}
</div>

<div class="section">
    <h2 id="Unitat7_Bloc2_Seccio2">Interf√≠cies</h2>
    
    <p>Una <strong>interf√≠cie</strong> defineix un contracte que les classes han de complir, especificant quins m√®todes han d'implementar sense proporcionar la implementaci√≥.</p>

    {% include definicio.html terme="Interf√≠cie" definicio="Contracte que especifica un conjunt de m√®todes que una classe ha d'implementar. Defineix 'qu√®' ha de fer una classe, per√≤ no 'com' ho ha de fer." %}

    <h3>Caracter√≠stiques de les Interf√≠cies</h3>
    
    <ul>
        <li>Tots els m√®todes s√≥n impl√≠citament <code>public</code> i <code>abstract</code> (Java 7 i anteriors)</li>
        <li>Poden tenir m√®todes per defecte i est√†tics (Java 8+)</li>
        <li>Tots els atributs s√≥n impl√≠citament <code>public</code>, <code>static</code> i <code>final</code></li>
        <li>Una classe pot implementar m√∫ltiples interf√≠cies</li>
        <li>Les interf√≠cies poden estendre altres interf√≠cies</li>
    </ul>

    <h3>Sintaxi i Exemple B√†sic</h3>
    
    {% capture code_interficie_basica %}
// Interf√≠cie b√†sica
public interface Drawable {
    // Constant (impl√≠citament public static final)
    String DEFAULT_COLOR = "Negre";
    
    // M√®todes abstractes (impl√≠citament public abstract)
    void dibuixar();
    void moure(int x, int y);
    void canviarColor(String color);
}

// Interf√≠cie per objectes que es poden redimensionar
public interface Resizable {
    void redimensionar(double factor);
    double getArea();
}

// Interf√≠cie per objectes que es poden rotar
public interface Rotatable {
    void rotar(double angle);
    double getAngle();
}

// Classe que implementa m√∫ltiples interf√≠cies
public class Rectangle implements Drawable, Resizable, Rotatable {
    private double ample, alt;
    private int x, y;
    private String color;
    private double angle;
    
    public Rectangle(double ample, double alt) {
        this.ample = ample;
        this.alt = alt;
        this.x = 0;
        this.y = 0;
        this.color = Drawable.DEFAULT_COLOR;
        this.angle = 0.0;
    }
    
    // Implementaci√≥ de Drawable
    @Override
    public void dibuixar() {
        System.out.printf("Dibuixant rectangle de %.1fx%.1f a (%d,%d) en color %s%n",
                         ample, alt, x, y, color);
    }
    
    @Override
    public void moure(int x, int y) {
        this.x = x;
        this.y = y;
        System.out.printf("Rectangle mogut a (%d,%d)%n", x, y);
    }
    
    @Override
    public void canviarColor(String color) {
        this.color = color;
        System.out.println("Color canviat a: " + color);
    }
    
    // Implementaci√≥ de Resizable
    @Override
    public void redimensionar(double factor) {
        this.ample *= factor;
        this.alt *= factor;
        System.out.printf("Rectangle redimensionat (factor %.2f): %.1fx%.1f%n", 
                         factor, ample, alt);
    }
    
    @Override
    public double getArea() {
        return ample * alt;
    }
    
    // Implementaci√≥ de Rotatable
    @Override
    public void rotar(double angle) {
        this.angle += angle;
        System.out.printf("Rectangle rotat %.1f graus (total: %.1f)%n", angle, this.angle);
    }
    
    @Override
    public double getAngle() {
        return angle;
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_interficie_basica %}

    <h3>M√®todes per Defecte i Est√†tics (Java 8+)</h3>
    
    {% capture code_interficie_avancada %}
public interface Shape {
    // M√®tode abstracte tradicional
    double calcularArea();
    
    // M√®tode per defecte (Java 8+)
    default void mostrarInfo() {
        System.out.println("Aquesta √©s una forma amb √†rea: " + calcularArea());
    }
    
    default boolean esGran() {
        return calcularArea() > 100.0;
    }
    
    // M√®tode est√†tic (Java 8+)
    static void compararArea(Shape s1, Shape s2) {
        System.out.printf("Forma 1: %.2f, Forma 2: %.2f%n", 
                         s1.calcularArea(), s2.calcularArea());
        if (s1.calcularArea() > s2.calcularArea()) {
            System.out.println("La forma 1 √©s m√©s gran");
        } else if (s2.calcularArea() > s1.calcularArea()) {
            System.out.println("La forma 2 √©s m√©s gran");
        } else {
            System.out.println("Les formes tenen la mateixa √†rea");
        }
    }
}

public class Cercle implements Shape {
    private double radi;
    
    public Cercle(double radi) {
        this.radi = radi;
    }
    
    @Override
    public double calcularArea() {
        return Math.PI * radi * radi;
    }
    
    // Pot sobrescriure el m√®tode per defecte si cal
    @Override
    public void mostrarInfo() {
        System.out.printf("Cercle amb radi %.2f i √†rea %.2f%n", radi, calcularArea());
    }
}

// Exemple d'√∫s
public class ExempleInterficies {
    public static void main(String[] args) {
        Cercle cercle = new Cercle(5.0);
        Rectangle rectangle = new Rectangle(4.0, 6.0);
        
        // Usar m√®todes implementats
        System.out.println("=== Operacions b√†siques ===");
        cercle.mostrarInfo();
        rectangle.dibuixar();
        rectangle.moure(10, 20);
        
        // Usar m√®todes per defecte
        System.out.println("\n=== M√®todes per defecte ===");
        System.out.println("El cercle √©s gran? " + cercle.esGran());
        System.out.println("El rectangle √©s gran? " + rectangle.esGran());
        
        // Usar m√®tode est√†tic
        System.out.println("\n=== Comparaci√≥ d'√†rees ===");
        Shape.compararArea(cercle, rectangle);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_interficie_avancada %}

    <h3>Her√®ncia d'Interf√≠cies</h3>
    
    {% capture code_herencia_interfaces %}
// Interf√≠cie base
public interface Movable {
    void moure(int deltaX, int deltaY);
    void setPosition(int x, int y);
}

// Interf√≠cie que est√©n Movable
public interface Animated extends Movable {
    void iniciarAnimacio();
    void aturarAnimacio();
    boolean estaAnimant();
    
    // M√®tode per defecte que usa m√®todes de la interf√≠cie pare
    default void animarMoviment(int x, int y, int steps) {
        iniciarAnimacio();
        for (int i = 1; i <= steps; i++) {
            moure(x/steps, y/steps);
            try {
                Thread.sleep(100); // Pausa per veure l'animaci√≥
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        aturarAnimacio();
    }
}

// Classe que implementa la interf√≠cie estesa
public class Sprite implements Animated {
    private int x, y;
    private String nom;
    private boolean animating;
    
    public Sprite(String nom) {
        this.nom = nom;
        this.x = 0;
        this.y = 0;
        this.animating = false;
    }
    
    // Implementaci√≥ de Movable
    @Override
    public void moure(int deltaX, int deltaY) {
        this.x += deltaX;
        this.y += deltaY;
        System.out.printf("%s mogut a (%d, %d)%n", nom, x, y);
    }
    
    @Override
    public void setPosition(int x, int y) {
        this.x = x;
        this.y = y;
        System.out.printf("%s posicionat a (%d, %d)%n", nom, x, y);
    }
    
    // Implementaci√≥ de Animated
    @Override
    public void iniciarAnimacio() {
        animating = true;
        System.out.println(nom + " ha comen√ßat l'animaci√≥");
    }
    
    @Override
    public void aturarAnimacio() {
        animating = false;
        System.out.println(nom + " ha aturat l'animaci√≥");
    }
    
    @Override
    public boolean estaAnimant() {
        return animating;
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_herencia_interfaces %}

    {% include success_box.html
       contingut="<strong>Avantatges de les interf√≠cies:</strong><br>
       ‚Ä¢ Permeten her√®ncia m√∫ltiple de comportament<br>
       ‚Ä¢ Defineixen contractes clars entre classes<br>
       ‚Ä¢ Faciliten el testing amb mocks<br>
       ‚Ä¢ Promouen el desacoblament de codi<br>
       ‚Ä¢ Essencials per a molts patrons de disseny"
    %}
</div>

<div class="section">
    <h2 id="Unitat7_Bloc2_Seccio3">Classes Abstractes vs Interf√≠cies</h2>
    
    <p>Tant les classes abstractes com les interf√≠cies permeten definir m√®todes que han de ser implementats per altres classes, per√≤ tenen difer√®ncies importants:</p>

    <table class="responsive-table">
        <thead>
            <tr>
                <th>Aspecte</th>
                <th>Classe Abstracta</th>
                <th>Interf√≠cie</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Her√®ncia</strong></td>
                <td>Una sola classe (extends)</td>
                <td>M√∫ltiples interf√≠cies (implements)</td>
            </tr>
            <tr>
                <td><strong>M√®todes</strong></td>
                <td>Concrets i abstractes</td>
                <td>Abstractes, per defecte i est√†tics</td>
            </tr>
            <tr>
                <td><strong>Atributs</strong></td>
                <td>Qualsevol tipus d'atribut</td>
                <td>Nom√©s constants (public static final)</td>
            </tr>
            <tr>
                <td><strong>Constructors</strong></td>
                <td>S√≠, poden tenir</td>
                <td>No</td>
            </tr>
            <tr>
                <td><strong>Modificadors d'acc√©s</strong></td>
                <td>Qualsevol</td>
                <td>Nom√©s public (impl√≠cit)</td>
            </tr>
            <tr>
                <td><strong>Quan usar</strong></td>
                <td>Relaci√≥ "√©s un" amb codi com√∫</td>
                <td>Contracte de comportament</td>
            </tr>
        </tbody>
    </table>

    <h3>Exemple Comparatiu Pr√†ctic</h3>
    
    {% capture code_comparacio_abstract_interface %}
// ESCENARI: Sistema de pagaments

// Opci√≥ 1: Classe abstracta quan hi ha codi com√∫
public abstract class ProcessadorPagament {
    protected String nomProcessador;
    protected double comissio;
    
    public ProcessadorPagament(String nom, double comissio) {
        this.nomProcessador = nom;
        this.comissio = comissio;
    }
    
    // M√®tode concret com√∫ a tots els processadors
    public double calcularComissio(double amount) {
        return amount * comissio;
    }
    
    public void registrarTransaccio(double amount) {
        System.out.printf("Transacci√≥ de %.2f‚Ç¨ registrada amb %s%n", amount, nomProcessador);
    }
    
    // M√®todes abstractes que han d'implementar les subclasses
    public abstract boolean processarPagament(double amount);
    public abstract void verificarFons(double amount);
}

class ProcessadorTarjeta extends ProcessadorPagament {
    private String numeroTarjeta;
    
    public ProcessadorTarjeta(String numero) {
        super("Processador Targeta", 0.025); // 2.5% comissi√≥
        this.numeroTarjeta = numero;
    }
    
    @Override
    public boolean processarPagament(double amount) {
        verificarFons(amount);
        System.out.printf("Pagament de %.2f‚Ç¨ processat amb targeta ****%s%n", 
                         amount, numeroTarjeta.substring(numeroTarjeta.length()-4));
        return true;
    }
    
    @Override
    public void verificarFons(double amount) {
        System.out.println("Verificant fons amb el banc...");
        // L√≤gica espec√≠fica per targetes
    }
}

// Opci√≥ 2: Interf√≠cie per definir contractes
public interface Reemborsable {
    boolean pucReemborsar(String transaccioId);
    void procesarReemborsament(String transaccioId, double amount);
}

public interface Encriptable {
    String encriptar(String dades);
    String desencriptar(String dades);
}

// Classe que combina her√®ncia d'abstracta amb implementaci√≥ d'interf√≠cies
class ProcessadorPayPal extends ProcessadorPagament 
                        implements Reemborsable, Encriptable {
    
    public ProcessadorPayPal() {
        super("PayPal", 0.029); // 2.9% comissi√≥
    }
    
    @Override
    public boolean processarPagament(double amount) {
        String dadesEncriptades = encriptar("amount:" + amount);
        verificarFons(amount);
        System.out.printf("Pagament de %.2f‚Ç¨ processat via PayPal%n", amount);
        return true;
    }
    
    @Override
    public void verificarFons(double amount) {
        System.out.println("Verificant compte PayPal...");
    }
    
    // Implementaci√≥ de Reemborsable
    @Override
    public boolean pucReemborsar(String transaccioId) {
        return true; // PayPal sempre permet reemborsaments
    }
    
    @Override
    public void procesarReemborsament(String transaccioId, double amount) {
        System.out.printf("Reemborsament de %.2f‚Ç¨ processat per PayPal (ID: %s)%n", 
                         amount, transaccioId);
    }
    
    // Implementaci√≥ de Encriptable
    @Override
    public String encriptar(String dades) {
        return "ENC_" + dades + "_ENC"; // Simulaci√≥ simple
    }
    
    @Override
    public String desencriptar(String dades) {
        return dades.replace("ENC_", "").replace("_ENC", "");
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_comparacio_abstract_interface %}

    <h3>Quan Usar Cadascun</h3>
    
    {% include info_box.html
       contingut="<strong>Usa CLASSE ABSTRACTA quan:</strong><br>
       ‚Ä¢ Vols compartir codi entre classes relacionades<br>
       ‚Ä¢ Necessites atributs no constants<br>
       ‚Ä¢ Vols proporcionar implementaci√≥ per defecte<br>
       ‚Ä¢ Hi ha una relaci√≥ jer√†rquica clara<br><br>
       
       <strong>Usa INTERF√çCIE quan:</strong><br>
       ‚Ä¢ Vols definir un contracte de comportament<br>
       ‚Ä¢ Necessites her√®ncia m√∫ltiple<br>
       ‚Ä¢ Vols permetre implementaci√≥ flexible<br>
       ‚Ä¢ Les classes no estan relacionades jer√†rquicament"
    %}

    {% include prompt-ai.html
       contingut="Qu√® passa si una classe implementa dues interf√≠cies que tenen el mateix m√®tode? Com es resol?"
    %}
</div>

<div class="section">
    <h2 id="Unitat7_Bloc2_Seccio4">Principis SOLID</h2>
    
    <p>Els principis <strong>SOLID</strong> s√≥n cinc principis de disseny orientat a objectes que ajuden a crear codi m√©s mantenible, flexible i robust.</p>

    {% include definicio.html terme="SOLID" definicio="Acr√≤nim de cinc principis de disseny de programari: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, i Dependency Inversion." %}

    <h3>1. Single Responsibility Principle (SRP)</h3>
    
    <p><strong>"Una classe ha de tenir nom√©s una ra√≥ per canviar"</strong></p>
    
    {% include warning_box.html
       contingut="<strong>Problema:</strong> Classes que fan massa coses s√≥n dif√≠cils de mantenir, provar i reutilitzar."
    %}

    {% capture code_srp %}
// ‚ùå Violaci√≥ del SRP - La classe fa massa coses
class GestorUsuari {
    public void crearUsuari(String nom, String email) {
        // Validaci√≥
        if (nom == null || email == null) {
            throw new IllegalArgumentException("Nom i email s√≥n obligatoris");
        }
        
        // Guardar a base de dades
        System.out.println("Guardant usuari a la BD: " + nom);
        
        // Enviar email de benvinguda
        System.out.println("Enviant email de benvinguda a: " + email);
        
        // Registrar en logs
        System.out.println("LOG: Usuari creat - " + nom);
    }
}

// ‚úÖ Aplicaci√≥ del SRP - Responsabilitats separades
class Usuari {
    private String nom;
    private String email;
    
    public Usuari(String nom, String email) {
        this.nom = nom;
        this.email = email;
    }
    
    // Getters i validaci√≥ b√†sica
    public String getNom() { return nom; }
    public String getEmail() { return email; }
    
    public boolean esValid() {
        return nom != null && !nom.trim().isEmpty() && 
               email != null && email.contains("@");
    }
}

class RepositoriUsuari {
    public void guardar(Usuari usuari) {
        System.out.println("Guardant usuari a la BD: " + usuari.getNom());
    }
}

class ServeiEmail {
    public void enviarBenvinguda(Usuari usuari) {
        System.out.println("Enviant email de benvinguda a: " + usuari.getEmail());
    }
}

class Logger {
    public void registrar(String missatge) {
        System.out.println("LOG: " + missatge);
    }
}

// Classe que coordina (per√≤ no fa tot)
class ServeiUsuari {
    private RepositoriUsuari repositori;
    private ServeiEmail serveiEmail;
    private Logger logger;
    
    public ServeiUsuari() {
        this.repositori = new RepositoriUsuari();
        this.serveiEmail = new ServeiEmail();
        this.logger = new Logger();
    }
    
    public void crearUsuari(String nom, String email) {
        Usuari usuari = new Usuari(nom, email);
        
        if (!usuari.esValid()) {
            throw new IllegalArgumentException("Dades d'usuari no v√†lides");
        }
        
        repositori.guardar(usuari);
        serveiEmail.enviarBenvinguda(usuari);
        logger.registrar("Usuari creat - " + usuari.getNom());
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_srp %}

    <h3>2. Open/Closed Principle (OCP)</h3>
    
    <p><strong>"Les entitats de programari han d'estar obertes per a l'extensi√≥ per√≤ tancades per a la modificaci√≥"</strong></p>

    {% capture code_ocp %}
// ‚ùå Violaci√≥ del OCP - Cal modificar la classe per afegir nous tipus
class CalculadoraArea {
    public double calcularArea(Object forma) {
        if (forma instanceof Rectangle) {
            Rectangle r = (Rectangle) forma;
            return r.getAmple() * r.getAlt();
        } else if (forma instanceof Cercle) {
            Cercle c = (Cercle) forma;
            return Math.PI * c.getRadi() * c.getRadi();
        }
        // Per afegir Triangle, cal modificar aquesta classe ‚ùå
        return 0;
    }
}

// ‚úÖ Aplicaci√≥ del OCP - Extensible sense modificaci√≥
interface Forma {
    double calcularArea();
}

class RectangleOCP implements Forma {
    private double ample, alt;
    
    public RectangleOCP(double ample, double alt) {
        this.ample = ample;
        this.alt = alt;
    }
    
    @Override
    public double calcularArea() {
        return ample * alt;
    }
}

class CercleOCP implements Forma {
    private double radi;
    
    public CercleOCP(double radi) {
        this.radi = radi;
    }
    
    @Override
    public double calcularArea() {
        return Math.PI * radi * radi;
    }
}

// Nova forma es pot afegir sense modificar el calculador ‚úÖ
class TriangleOCP implements Forma {
    private double base, altura;
    
    public TriangleOCP(double base, double altura) {
        this.base = base;
        this.altura = altura;
    }
    
    @Override
    public double calcularArea() {
        return (base * altura) / 2.0;
    }
}

class CalculadoraAreaOCP {
    public double calcularArea(Forma forma) {
        return forma.calcularArea(); // No cal modificar mai aquesta classe!
    }
    
    public double calcularAreaTotal(Forma[] formes) {
        double total = 0;
        for (Forma forma : formes) {
            total += forma.calcularArea();
        }
        return total;
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_ocp %}

    <h3>3. Liskov Substitution Principle (LSP)</h3>
    
    <p><strong>"Els objectes de les subclasses han de poder substituir els objectes de la superclasse sense trencar la funcionalitat"</strong></p>

    {% capture code_lsp %}
// ‚ùå Violaci√≥ del LSP
class Ocell {
    public void volar() {
        System.out.println("L'ocell est√† volant");
    }
}

class Pingui extends Ocell {
    @Override
    public void volar() {
        throw new UnsupportedOperationException("Els ping√ºins no poden volar!");
    }
}

// Problema: Pingui no es pot usar on s'espera un Ocell
// public static void ferVolarOcell(Ocell ocell) {
//     ocell.volar(); // Fallar√† amb Pingui!
// }

// ‚úÖ Aplicaci√≥ del LSP - Jerarquia correcta
abstract class OcellLSP {
    public abstract void moure();
    
    public void menjar() {
        System.out.println("L'ocell est√† menjant");
    }
}

class OcellVolador extends OcellLSP {
    @Override
    public void moure() {
        volar();
    }
    
    public void volar() {
        System.out.println("L'ocell est√† volant");
    }
}

class OcellCaminador extends OcellLSP {
    @Override
    public void moure() {
        caminar();
    }
    
    public void caminar() {
        System.out.println("L'ocell est√† caminant");
    }
}

class Aguila extends OcellVolador {
    @Override
    public void volar() {
        System.out.println("L'√†guila vola alt i r√†pid");
    }
}

class PinguiLSP extends OcellCaminador {
    @Override
    public void caminar() {
        System.out.println("El ping√º√≠ camina i neda");
    }
    
    public void nedar() {
        System.out.println("El ping√º√≠ neda molt b√©");
    }
}

// Ara funciona correctament
class GestorOcells {
    public static void ferMoureOcell(OcellLSP ocell) {
        ocell.moure(); // Funciona amb qualsevol subclasse ‚úÖ
        ocell.menjar(); // Tamb√© funciona
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_lsp %}

    <h3>4. Interface Segregation Principle (ISP)</h3>
    
    <p><strong>"Cap client no ha de ser for√ßat a dependre d'interf√≠cies que no utilitza"</strong></p>

    {% capture code_isp %}
// ‚ùå Violaci√≥ del ISP - Interf√≠cie massa gran
interface Treballador {
    void treballar();
    void menjar();
    void dormir();
    void programar();      // No tots els treballadors programen!
    void dissenyar();      // No tots els treballadors dissenyen!
    void gestionar();      // No tots els treballadors gestionen!
}

// ‚úÖ Aplicaci√≥ del ISP - Interf√≠cies espec√≠fiques
interface Treballable {
    void treballar();
}

interface Alimentable {
    void menjar();
}

interface Descansable {
    void dormir();
}

interface Programable {
    void programar();
}

interface Dissenyable {
    void dissenyar();
}

interface Gestionar {
    void gestionar();
}

// Les classes nom√©s implementen el que necessiten
class Programador implements Treballable, Alimentable, Descansable, Programable {
    @Override
    public void treballar() {
        System.out.println("Programador treballant en codi");
    }
    
    @Override
    public void menjar() {
        System.out.println("Programador menjant (probablement pizza)");
    }
    
    @Override
    public void dormir() {
        System.out.println("Programador dormint (poc)");
    }
    
    @Override
    public void programar() {
        System.out.println("Escrivint codi Java");
    }
}

class Dissenyador implements Treballable, Alimentable, Descansable, Dissenyable {
    @Override
    public void treballar() {
        System.out.println("Dissenyador creant interf√≠cies");
    }
    
    @Override
    public void menjar() {
        System.out.println("Dissenyador menjant saludablement");
    }
    
    @Override
    public void dormir() {
        System.out.println("Dissenyador dormint per inspiraci√≥");
    }
    
    @Override
    public void dissenyar() {
        System.out.println("Creant dissenys UX/UI");
    }
}

class Gerent implements Treballable, Alimentable, Descansable, Gestionar {
    @Override
    public void treballar() {
        System.out.println("Gerent coordinant l'equip");
    }
    
    @Override
    public void menjar() {
        System.out.println("Gerent menjant en reunions");
    }
    
    @Override
    public void dormir() {
        System.out.println("Gerent dormint poc per stress");
    }
    
    @Override
    public void gestionar() {
        System.out.println("Gestionant projectes i personal");
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_isp %}

    <h3>5. Dependency Inversion Principle (DIP)</h3>
    
    <p><strong>"Dependre d'abstraccions, no de concrecions"</strong></p>

    {% capture code_dip %}
// ‚ùå Violaci√≥ del DIP - Depend√®ncia de concrecions
class ServeiEmailConcret {
    public void enviarEmail(String destinatari, String missatge) {
        System.out.println("Enviant email via Gmail a " + destinatari + ": " + missatge);
    }
}

class NotificadorConcret {
    private ServeiEmailConcret serveiEmail; // Depend√®ncia concreta ‚ùå
    
    public NotificadorConcret() {
        this.serveiEmail = new ServeiEmailConcret(); // Acoblament fort ‚ùå
    }
    
    public void notificar(String usuari, String missatge) {
        serveiEmail.enviarEmail(usuari, missatge);
    }
}

// ‚úÖ Aplicaci√≥ del DIP - Depend√®ncia d'abstraccions
interface ServeiNotificacio {
    void enviarNotificacio(String destinatari, String missatge);
}

class ServeiEmail implements ServeiNotificacio {
    @Override
    public void enviarNotificacio(String destinatari, String missatge) {
        System.out.println("Email enviat a " + destinatari + ": " + missatge);
    }
}

class ServeiSMS implements ServeiNotificacio {
    @Override
    public void enviarNotificacio(String destinatari, String missatge) {
        System.out.println("SMS enviat a " + destinatari + ": " + missatge);
    }
}

class ServeiPush implements ServeiNotificacio {
    @Override
    public void enviarNotificacio(String destinatari, String missatge) {
        System.out.println("Push notification enviada a " + destinatari + ": " + missatge);
    }
}

// Notificador que dep√®n d'abstracci√≥
class Notificador {
    private ServeiNotificacio serveiNotificacio; // Depend√®ncia d'abstracci√≥ ‚úÖ
    
    // Injecci√≥ de depend√®ncia via constructor
    public Notificador(ServeiNotificacio serveiNotificacio) {
        this.serveiNotificacio = serveiNotificacio;
    }
    
    public void notificar(String usuari, String missatge) {
        serveiNotificacio.enviarNotificacio(usuari, missatge);
    }
    
    // M√®tode per canviar el servei en runtime
    public void canviarServei(ServeiNotificacio nouServei) {
        this.serveiNotificacio = nouServei;
    }
}

// Exemple d'√∫s flexible
class ExempleDIP {
    public static void main(String[] args) {
        // Podem canviar f√†cilment la implementaci√≥
        Notificador notificador = new Notificador(new ServeiEmail());
        notificador.notificar("user@email.com", "Hola m√≥n!");
        
        // Canviar a SMS sense modificar Notificador
        notificador.canviarServei(new ServeiSMS());
        notificador.notificar("123456789", "Hola via SMS!");
        
        // Canviar a Push notifications
        notificador.canviarServei(new ServeiPush());
        notificador.notificar("user123", "Hola via Push!");
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_dip %}

    {% include success_box.html
       contingut="<strong>Beneficis dels principis SOLID:</strong><br>
       ‚Ä¢ Codi m√©s mantenible i llegible<br>
       ‚Ä¢ Facilitat per afegir noves funcionalitats<br>
       ‚Ä¢ Millor testabilitat del codi<br>
       ‚Ä¢ Menor acoblament entre components<br>
       ‚Ä¢ Major reutilitzaci√≥ de codi"
    %}

    {% include prompt-ai.html
       contingut="Qu√® vol dir que una classe 'depenga d'abstraccions i no de concrecions'? Pots donar-me un exemple simple?"
    %}
</div>

<div class="section">
    <h2 id="Unitat7_Bloc2_Seccio5">Introducci√≥ als Patrons de Disseny</h2>
    
    <p>Els <strong>patrons de disseny</strong> s√≥n solucions reutilitzables a problemes comuns en el disseny de programari. Representen les millors pr√†ctiques desenvolupades per programadors experimentats.</p>

    {% include definicio.html terme="Patr√≥ de Disseny" definicio="Soluci√≥ general i reutilitzable a un problema com√∫ en el disseny de programari. Descriuen com organitzar classes i objectes per resoldre problemes espec√≠fics." %}

    <h3>Tipus de Patrons de Disseny</h3>
    
    <ul>
        <li><strong>Patrons Creacionals:</strong> Com crear objectes (Singleton, Factory, Builder)</li>
        <li><strong>Patrons Estructurals:</strong> Com compondre objectes (Adapter, Decorator, Facade)</li>
        <li><strong>Patrons de Comportament:</strong> Com interactuen els objectes (Observer, Strategy, Command)</li>
    </ul>

    <h3>Patr√≥ Singleton (Creacional)</h3>
    
    <p>Garanteix que una classe nom√©s tingui una inst√†ncia i proporciona un punt d'acc√©s global a aquesta inst√†ncia.</p>

    {% capture code_singleton %}
// Implementaci√≥ Thread-Safe del Singleton
public class ConfiguradorSistema {
    // Inst√†ncia √∫nica (volatile per a thread safety)
    private static volatile ConfiguradorSistema instancia;
    
    // Configuraci√≥ del sistema
    private String baseDades;
    private String servidorEmail;
    private int portAPI;
    
    // Constructor privat per evitar instanciaci√≥ externa
    private ConfiguradorSistema() {
        // Carregar configuraci√≥ per defecte
        this.baseDades = "localhost:5432/app";
        this.servidorEmail = "smtp.email.com";
        this.portAPI = 8080;
    }
    
    // M√®tode per obtenir la inst√†ncia √∫nica (thread-safe)
    public static ConfiguradorSistema getInstance() {
        if (instancia == null) {
            synchronized (ConfiguradorSistema.class) {
                if (instancia == null) {
                    instancia = new ConfiguradorSistema();
                }
            }
        }
        return instancia;
    }
    
    // M√®todes de configuraci√≥
    public String getBaseDades() { return baseDades; }
    public void setBaseDades(String baseDades) { this.baseDades = baseDades; }
    
    public String getServidorEmail() { return servidorEmail; }
    public void setServidorEmail(String servidorEmail) { this.servidorEmail = servidorEmail; }
    
    public int getPortAPI() { return portAPI; }
    public void setPortAPI(int portAPI) { this.portAPI = portAPI; }
    
    public void mostrarConfiguracio() {
        System.out.println("=== Configuraci√≥ del Sistema ===");
        System.out.println("Base de dades: " + baseDades);
        System.out.println("Servidor email: " + servidorEmail);
        System.out.println("Port API: " + portAPI);
    }
}

// Exemple d'√∫s
class ExempleSingleton {
    public static void main(String[] args) {
        // Obtenir la inst√†ncia √∫nica
        ConfiguradorSistema config1 = ConfiguradorSistema.getInstance();
        ConfiguradorSistema config2 = ConfiguradorSistema.getInstance();
        
        // Verificar que √©s la mateixa inst√†ncia
        System.out.println("√âs la mateixa inst√†ncia? " + (config1 == config2));
        
        // Modificar configuraci√≥ des d'una refer√®ncia
        config1.setBaseDades("production.db.com:5432/app");
        
        // La modificaci√≥ es veu des de totes les refer√®ncies
        config2.mostrarConfiguracio();
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_singleton %}

    <h3>Patr√≥ Observer (Comportament)</h3>
    
    <p>Defineix una depend√®ncia un-a-molts entre objectes de manera que quan un objecte canvia d'estat, tots els seus dependents s√≥n notificats autom√†ticament.</p>

    {% capture code_observer %}
import java.util.*;

// Interf√≠cie per als observadors
interface ObservadorTemperatura {
    void actualitzarTemperatura(double temperatura);
}

// Subject (Observable)
class SensorTemperatura {
    private List<ObservadorTemperatura> observadors;
    private double temperatura;
    
    public SensorTemperatura() {
        this.observadors = new ArrayList<>();
        this.temperatura = 20.0; // Temperatura inicial
    }
    
    // Gesti√≥ d'observadors
    public void afegirObservador(ObservadorTemperatura observador) {
        observadors.add(observador);
        System.out.println("Observador afegit. Total: " + observadors.size());
    }
    
    public void eliminarObservador(ObservadorTemperatura observador) {
        observadors.remove(observador);
        System.out.println("Observador eliminat. Total: " + observadors.size());
    }
    
    // Notificar a tots els observadors
    private void notificarObservadors() {
        System.out.println("Notificant " + observadors.size() + " observadors...");
        for (ObservadorTemperatura observador : observadors) {
            observador.actualitzarTemperatura(temperatura);
        }
    }
    
    // Canviar temperatura i notificar
    public void setTemperatura(double novaTemperatura) {
        if (this.temperatura != novaTemperatura) {
            System.out.printf("Temperatura canviada de %.1f¬∞C a %.1f¬∞C%n", 
                             this.temperatura, novaTemperatura);
            this.temperatura = novaTemperatura;
            notificarObservadors();
        }
    }
    
    public double getTemperatura() {
        return temperatura;
    }
}

// Observadors concrets
class DisplayTemperatura implements ObservadorTemperatura {
    private String nom;
    
    public DisplayTemperatura(String nom) {
        this.nom = nom;
    }
    
    @Override
    public void actualitzarTemperatura(double temperatura) {
        System.out.printf("[%s] Mostrant temperatura: %.1f¬∞C%n", nom, temperatura);
    }
}

class AlertaTemperatura implements ObservadorTemperatura {
    private double llindarAlt;
    private double llindarBaix;
    
    public AlertaTemperatura(double llindarBaix, double llindarAlt) {
        this.llindarBaix = llindarBaix;
        this.llindarAlt = llindarAlt;
    }
    
    @Override
    public void actualitzarTemperatura(double temperatura) {
        if (temperatura > llindarAlt) {
            System.out.printf("‚ö†Ô∏è ALERTA: Temperatura massa alta! %.1f¬∞C (m√†x: %.1f¬∞C)%n", 
                             temperatura, llindarAlt);
        } else if (temperatura < llindarBaix) {
            System.out.printf("‚ùÑÔ∏è ALERTA: Temperatura massa baixa! %.1f¬∞C (m√≠n: %.1f¬∞C)%n", 
                             temperatura, llindarBaix);
        } else {
            System.out.printf("‚úÖ Temperatura dins del rang normal: %.1f¬∞C%n", temperatura);
        }
    }
}

class RegistradorTemperatura implements ObservadorTemperatura {
    private List<String> historial;
    
    public RegistradorTemperatura() {
        this.historial = new ArrayList<>();
    }
    
    @Override
    public void actualitzarTemperatura(double temperatura) {
        String registre = String.format("%.1f¬∞C a %s", 
                                       temperatura, new Date().toString());
        historial.add(registre);
        System.out.printf("üìù Registrat: %s%n", registre);
    }
    
    public void mostrarHistorial() {
        System.out.println("=== Historial de temperatures ===");
        for (String registre : historial) {
            System.out.println(registre);
        }
    }
}

// Exemple d'√∫s
class ExempleObserver {
    public static void main(String[] args) {
        // Crear el sensor (subject)
        SensorTemperatura sensor = new SensorTemperatura();
        
        // Crear observadors
        DisplayTemperatura display1 = new DisplayTemperatura("Display Principal");
        DisplayTemperatura display2 = new DisplayTemperatura("Display Secundari");
        AlertaTemperatura alerta = new AlertaTemperatura(5.0, 35.0);
        RegistradorTemperatura registrador = new RegistradorTemperatura();
        
        // Registrar observadors
        sensor.afegirObservador(display1);
        sensor.afegirObservador(display2);
        sensor.afegirObservador(alerta);
        sensor.afegirObservador(registrador);
        
        // Simular canvis de temperatura
        System.out.println("\n=== Simulant canvis de temperatura ===");
        sensor.setTemperatura(25.5);
        
        System.out.println("\n" + "=".repeat(50));
        sensor.setTemperatura(40.0); // Alerta alta
        
        System.out.println("\n" + "=".repeat(50));
        sensor.setTemperatura(-5.0); // Alerta baixa
        
        System.out.println("\n" + "=".repeat(50));
        sensor.setTemperatura(22.0); // Normal
        
        // Mostrar historial
        System.out.println("\n");
        registrador.mostrarHistorial();
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_observer %}

    <h3>Patr√≥ Strategy (Comportament)</h3>
    
    <p>Defineix una fam√≠lia d'algoritmes, encapsula cadascun i els fa intercanviables. Strategy permet que l'algoritme vari√Ø independentment dels clients que l'utilitzen.</p>

    {% capture code_strategy %}
// Estrat√®gia d'ordenaci√≥
interface EstrategiaOrdenacio {
    void ordenar(int[] array);
    String getNom();
}

// Implementacions concretes d'estrat√®gies
class BubbleSort implements EstrategiaOrdenacio {
    @Override
    public void ordenar(int[] array) {
        System.out.println("Ordenant amb Bubble Sort...");
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    // Intercanviar elements
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
    
    @Override
    public String getNom() {
        return "Bubble Sort";
    }
}

class QuickSort implements EstrategiaOrdenacio {
    @Override
    public void ordenar(int[] array) {
        System.out.println("Ordenant amb Quick Sort...");
        quickSort(array, 0, array.length - 1);
    }
    
    private void quickSort(int[] array, int low, int high) {
        if (low < high) {
            int pi = partition(array, low, high);
            quickSort(array, low, pi - 1);
            quickSort(array, pi + 1, high);
        }
    }
    
    private int partition(int[] array, int low, int high) {
        int pivot = array[high];
        int i = (low - 1);
        
        for (int j = low; j < high; j++) {
            if (array[j] <= pivot) {
                i++;
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
        
        int temp = array[i + 1];
        array[i + 1] = array[high];
        array[high] = temp;
        
        return i + 1;
    }
    
    @Override
    public String getNom() {
        return "Quick Sort";
    }
}

class SelectionSort implements EstrategiaOrdenacio {
    @Override
    public void ordenar(int[] array) {
        System.out.println("Ordenant amb Selection Sort...");
        for (int i = 0; i < array.length - 1; i++) {
            int minIdx = i;
            for (int j = i + 1; j < array.length; j++) {
                if (array[j] < array[minIdx]) {
                    minIdx = j;
                }
            }
            int temp = array[minIdx];
            array[minIdx] = array[i];
            array[i] = temp;
        }
    }
    
    @Override
    public String getNom() {
        return "Selection Sort";
    }
}

// Context que utilitza les estrat√®gies
class OrdenadorContext {
    private EstrategiaOrdenacio estrategia;
    
    public OrdenadorContext(EstrategiaOrdenacio estrategia) {
        this.estrategia = estrategia;
    }
    
    public void setEstrategia(EstrategiaOrdenacio estrategia) {
        this.estrategia = estrategia;
    }
    
    public void ordenarArray(int[] array) {
        long startTime = System.nanoTime();
        estrategia.ordenar(array);
        long endTime = System.nanoTime();
        
        System.out.printf("Ordenaci√≥ completada amb %s en %.2f ms%n", 
                         estrategia.getNom(), (endTime - startTime) / 1_000_000.0);
    }
    
    // Factory method per seleccionar estrat√®gia segons mida
    public static EstrategiaOrdenacio seleccionarEstrategia(int midaArray) {
        if (midaArray < 10) {
            return new BubbleSort(); // Simple per arrays petits
        } else if (midaArray < 100) {
            return new SelectionSort(); // Eficient per arrays mitjans
        } else {
            return new QuickSort(); // R√†pid per arrays grans
        }
    }
}

// Exemple d'√∫s
class ExempleStrategy {
    public static void main(String[] args) {
        // Arrays de prova
        int[] arrayPetit = {64, 34, 25, 12, 22, 11, 90};
        int[] arrayMitja = new int[50];
        int[] arrayGran = new int[1000];
        
        // Omplir arrays amb n√∫meros aleatoris
        Random random = new Random();
        for (int i = 0; i < arrayMitja.length; i++) {
            arrayMitja[i] = random.nextInt(100);
        }
        for (int i = 0; i < arrayGran.length; i++) {
            arrayGran[i] = random.nextInt(1000);
        }
        
        OrdenadorContext ordenador = new OrdenadorContext(new BubbleSort());
        
        // Ordenar array petit
        System.out.println("=== Array petit ===");
        System.out.println("Original: " + Arrays.toString(arrayPetit));
        ordenador.ordenarArray(arrayPetit.clone());
        
        // Canviar estrat√®gia autom√†ticament segons mida
        System.out.println("\n=== Array mitj√† (50 elements) ===");
        ordenador.setEstrategia(OrdenadorContext.seleccionarEstrategia(50));
        ordenador.ordenarArray(arrayMitja.clone());
        
        System.out.println("\n=== Array gran (1000 elements) ===");
        ordenador.setEstrategia(OrdenadorContext.seleccionarEstrategia(1000));
        ordenador.ordenarArray(arrayGran.clone());
        
        // Comparar totes les estrat√®gies en el mateix array
        System.out.println("\n=== Comparaci√≥ d'estrat√®gies ===");
        EstrategiaOrdenacio[] estrategies = {
            new BubbleSort(),
            new SelectionSort(),
            new QuickSort()
        };
        
        for (EstrategiaOrdenacio estrategia : estrategies) {
            ordenador.setEstrategia(estrategia);
            ordenador.ordenarArray(arrayMitja.clone());
        }
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_strategy %}

    {% include success_box.html
       contingut="<strong>Avantatges dels patrons de disseny:</strong><br>
       ‚Ä¢ Solucions provades a problemes comuns<br>
       ‚Ä¢ Milloren la comunicaci√≥ entre desenvolupadors<br>
       ‚Ä¢ Promouen bones pr√†ctiques de disseny<br>
       ‚Ä¢ Faciliten la reutilitzaci√≥ i manteniment del codi<br>
       ‚Ä¢ Basen en principis s√≤lids com SOLID"
    %}

    {% include prompt-ai.html
       contingut="En el patr√≥ Singleton, per qu√® el constructor ha de ser privat? Qu√® passaria si f√≥s p√∫blic?"
    %}
</div>

<div class="section">
    <h2 id="Unitat7_Bloc2_Seccio6">Pr√†ctiques</h2>
    
    <p>Exercicis avan√ßats per consolidar els conceptes de classes abstractes, interf√≠cies, principis SOLID i patrons de disseny.</p>

    {% include exercici.html 
       nom="Classes Abstractes vs Interf√≠cies"
       dificultat="F√†cil"
       temps="15 min"
       descripcio="<p>Practica la difer√®ncia entre classe abstracta i interf√≠cie:</p>
       <ul>
           <li>Crea la classe abstracta <code>Forma</code> amb m√®tode concret <code>mostrarInfo()</code> i abstracte <code>calcularArea()</code></li>
           <li>Crea la interf√≠cie <code>Coloreable</code> amb m√®todes <code>setColor()</code> i <code>getColor()</code></li>
           <li>Implementa <code>Cercle</code> que hereta de <code>Forma</code> i implementa <code>Coloreable</code></li>
       </ul>"
    %}

    {% include exercici.html 
       nom="Principi SRP"
       dificultat="F√†cil"
       temps="10 min"
       descripcio="<p>Identifica i corregeix violacions del principi de responsabilitat √∫nica:</p>
       <ul>
           <li>Analitza aquesta classe: <code>class Usuari { validar(), guardarBD(), enviarEmail() }</code></li>
           <li>Separa les responsabilitats en classes diferents</li>
           <li>Crea <code>ValidadorUsuari</code>, <code>RepositoriUsuari</code>, <code>ServeiEmail</code></li>
       </ul>"
    %}

    {% include exercici.html 
       nom="Patr√≥ Observer Simple"
       dificultat="Mitj√†"
       temps="20 min"
       descripcio="<p>Implementa un patr√≥ Observer b√†sic:</p>
       <ul>
           <li>Crea <code>TermostatObservable</code> que notifica canvis de temperatura</li>
           <li>Implementa dos observadors: <code>DisplayTemperatura</code> i <code>AlertaTemperatura</code></li>
           <li>Prova afegint/eliminant observadors i canviant la temperatura</li>
       </ul>"
    %}

    {% include prompt-ai.html
       contingut="En el patr√≥ Observer, com puc evitar que un observador rebenti tot el sistema si fa una excepci√≥?"
    %}
</div>