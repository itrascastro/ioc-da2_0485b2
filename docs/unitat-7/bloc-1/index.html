---
layout: bloc
title: "Bloc 1: Herència, polimorfisme i composició"
description: "Fonaments de la programació orientada a objectes: classes, objectes, herència, polimorfisme i composició"
keywords: "Java, POO, classes, objectes, herència, polimorfisme, composició, this, super"
unitat: 7
bloc: 1
bloc_numero: 1
---

<!--
  Pàgina de contingut del Bloc 1 (Unitat 7)
  Contingut basat en PDF: U7 - Nucli 1_ Herència, polimorfisme i composició.pdf
  + Fonaments de classes i objectes afegits
-->

<div class="section">
    <h2 id="Unitat7_Bloc1_Seccio1">Fonaments de la Programació Orientada a Objectes</h2>
    
    <p>La Programació Orientada a Objectes (POO) és un paradigma de programació que organitza el codi en <strong>classes</strong> i <strong>objectes</strong>, permetent una millor abstracció, reutilització i manteniment del codi.</p>

    {% include info_box.html
       contingut="Els pilars fonamentals de la POO són:<br>
       • <strong>Encapsulació:</strong> Agrupar dades i mètodes relacionats.<br>
       • <strong>Herència:</strong> Crear noves classes basades en classes existents.<br>
       • <strong>Polimorfisme:</strong> Utilitzar una interfície comuna per diferents tipus d'objectes.<br>
       • <strong>Abstracció:</strong> Amagar la complexitat interna i mostrar només el necessari."
    %}

    {% include prompt-ai.html
       contingut="Quin és l'avantatge d'usar encapsulació en lloc de fer tots els atributs públics? Explica amb un exemple simple."
    %}
</div>

<div class="section">
    <h2 id="Unitat7_Bloc1_Seccio2">Classes i Objectes en Java</h2>
    
    <h3>Definició de Classes</h3>
    
    <p>Una <strong>classe</strong> és un model o plantilla que defineix les propietats (atributs) i comportaments (mètodes) que tindran els objectes creats a partir d'ella.</p>

    {% include definicio.html terme="Classe" definicio="Plantilla que defineix els atributs i mètodes que compartiran tots els objectes del mateix tipus. És com un plànol per construir objectes." %}

    {% capture code_classe_basica %}
public class Persona {
    // Atributs (propietats de la classe)
    private String nom;
    private int edat;
    private String email;
    
    // Constructor per defecte
    public Persona() {
        this.nom = "";
        this.edat = 0;
        this.email = "";
    }
    
    // Constructor amb paràmetres
    public Persona(String nom, int edat, String email) {
        this.nom = nom;
        this.edat = edat;
        this.email = email;
    }
    
    // Mètodes getter i setter
    public String getNom() {
        return nom;
    }
    
    public void setNom(String nom) {
        this.nom = nom;
    }
    
    public int getEdat() {
        return edat;
    }
    
    public void setEdat(int edat) {
        if (edat >= 0) {
            this.edat = edat;
        }
    }
    
    // Mètode per mostrar informació
    public void mostrarInfo() {
        System.out.println("Nom: " + nom);
        System.out.println("Edat: " + edat);
        System.out.println("Email: " + email);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_classe_basica %}

    <h3>Creació i Ús d'Objectes</h3>
    
    <p>Un <strong>objecte</strong> és una instància concreta d'una classe. Quan creem un objecte, estem creant una entitat amb els atributs i mètodes definits en la seva classe.</p>

    {% include definicio.html terme="Objecte" definicio="Instància específica d'una classe que té valors concrets per als seus atributs i pot executar els mètodes definits en la classe." %}

    {% capture code_objectes %}
public class ExemplePersona {
    public static void main(String[] args) {
        // Crear objectes de la classe Persona
        Persona persona1 = new Persona();
        Persona persona2 = new Persona("Anna", 25, "anna@email.com");
        
        // Utilitzar mètodes dels objectes
        persona1.setNom("Jordi");
        persona1.setEdat(30);
        
        System.out.println("=== Persona 1 ===");
        persona1.mostrarInfo();
        
        System.out.println("\n=== Persona 2 ===");
        persona2.mostrarInfo();
        
        // Comparar objectes
        System.out.println("Són la mateixa persona? " + 
                          (persona1.getNom().equals(persona2.getNom())));
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_objectes %}

    <h3>Modificadors d'Accés</h3>
    
    <p>Java utilitza modificadors d'accés per controlar la visibilitat dels atributs i mètodes:</p>
    
    <table class="responsive-table">
        <thead>
            <tr>
                <th>Modificador</th>
                <th>Classe</th>
                <th>Paquet</th>
                <th>Subclasse</th>
                <th>Tots</th>
                <th>Ús Recomanat</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>private</code></td>
                <td>✓</td>
                <td>✗</td>
                <td>✗</td>
                <td>✗</td>
                <td>Atributs interns</td>
            </tr>
            <tr>
                <td><code>package</code> (per defecte)</td>
                <td>✓</td>
                <td>✓</td>
                <td>✗</td>
                <td>✗</td>
                <td>Classes del mateix paquet</td>
            </tr>
            <tr>
                <td><code>protected</code></td>
                <td>✓</td>
                <td>✓</td>
                <td>✓</td>
                <td>✗</td>
                <td>Herència</td>
            </tr>
            <tr>
                <td><code>public</code></td>
                <td>✓</td>
                <td>✓</td>
                <td>✓</td>
                <td>✓</td>
                <td>API pública</td>
            </tr>
        </tbody>
    </table>
</div>

<div class="section">
    <h2 id="Unitat7_Bloc1_Seccio3">La Paraula Clau 'this'</h2>
    
    <p>La paraula clau <code>this</code> fa referència a l'objecte actual dins d'un mètode o constructor. S'utilitza per:</p>
    
    <ul>
        <li>Diferenciar entre atributs i paràmetres amb el mateix nom</li>
        <li>Passar l'objecte actual com a paràmetre</li>
        <li>Cridar un constructor des d'un altre constructor</li>
    </ul>

    {% include definicio.html terme="this" definicio="Referència a l'objecte actual. Permet accedir als atributs i mètodes de l'instància actual des de dins la mateixa classe." %}

    <h3>Ús Bàsic de 'this'</h3>
    
    {% capture code_this_basic %}
public class Cotxe {
    private String marca;
    private String model;
    private int any;
    
    // Sense 'this' - noms diferents
    public void setMarca(String m) {
        marca = m; // Funciona, però no és clar
    }
    
    // Amb 'this' - noms iguals
    public void setModel(String model) {
        this.model = model; // Necessari per diferenciar
    }
    
    // Constructor amb 'this'
    public Cotxe(String marca, String model, int any) {
        this.marca = marca;
        this.model = model;
        this.any = any;
    }
    
    // Mètode que retorna 'this' per encadenar crides
    public Cotxe setAny(int any) {
        this.any = any;
        return this; // Permet encadenar mètodes
    }
    
    public void mostrarInfo() {
        System.out.println(this.marca + " " + this.model + " (" + this.any + ")");
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_this_basic %}

    <h3>Constructors Encadenats amb 'this'</h3>
    
    {% capture code_this_constructors %}
public class Producte {
    private String nom;
    private double preu;
    private String categoria;
    
    // Constructor principal
    public Producte(String nom, double preu, String categoria) {
        this.nom = nom;
        this.preu = preu;
        this.categoria = categoria;
    }
    
    // Constructor que crida al principal
    public Producte(String nom, double preu) {
        this(nom, preu, "General"); // Crida al constructor principal
    }
    
    // Constructor per defecte
    public Producte() {
        this("Producte", 0.0, "General"); // Crida al constructor principal
    }
    
    // Exemple d'encadenament de mètodes
    public static void main(String[] args) {
        Cotxe cotxe = new Cotxe("Toyota", "Corolla", 2020);
        cotxe.setAny(2023).mostrarInfo(); // Encadenament possible gràcies a 'return this'
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_this_constructors %}

    {% include success_box.html
       contingut="<strong>Bones pràctiques amb 'this':</strong><br>
       • Utilitzar sempre en constructors per claredat<br>
       • Usar quan hi ha ambigüitat de noms<br>
       • Retornar 'this' en mètodes setter per permetre encadenament<br>
       • Evitar l'ús innecessari quan no hi ha conflicte de noms"
    %}
</div>

<div class="section">
    <h2 id="Unitat7_Bloc1_Seccio4">Herència en Java</h2>
    
    <p>L'<strong>herència</strong> permet crear noves classes basades en classes existents, heretant els seus atributs i mètodes. És un dels pilars fonamentals de la POO.</p>

    {% include definicio.html terme="Herència" definicio="Mecanisme que permet crear una nova classe (subclasse) basada en una classe existent (superclasse), heretant els seus atributs i mètodes." %}

    <h3>Conceptes Bàsics</h3>
    
    <ul>
        <li><strong>Superclasse (classe pare):</strong> La classe de la qual s'hereta</li>
        <li><strong>Subclasse (classe filla):</strong> La classe que hereta</li>
        <li><strong>Paraula clau extends:</strong> Indica relació d'herència</li>
        <li><strong>Paraula clau super:</strong> Referència a la superclasse</li>
    </ul>

    {% capture code_herencia_basica %}
// Superclasse
public class Animal {
    protected String nom;
    protected int edat;
    
    public Animal(String nom, int edat) {
        this.nom = nom;
        this.edat = edat;
    }
    
    public void menjar() {
        System.out.println(nom + " està menjant");
    }
    
    public void dormir() {
        System.out.println(nom + " està dormint");
    }
    
    public void mostrarInfo() {
        System.out.println("Nom: " + nom + ", Edat: " + edat);
    }
}

// Subclasse
public class Gos extends Animal {
    private String raca;
    
    public Gos(String nom, int edat, String raca) {
        super(nom, edat); // Crida al constructor de la superclasse
        this.raca = raca;
    }
    
    // Mètode específic de Gos
    public void bordar() {
        System.out.println(nom + " està bordant: Bup bup!");
    }
    
    // Sobrescriptura de mètode
    @Override
    public void mostrarInfo() {
        super.mostrarInfo(); // Crida al mètode de la superclasse
        System.out.println("Raça: " + raca);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_herencia_basica %}

    <h3>La Paraula Clau 'super'</h3>
    
    <p><code>super</code> s'utilitza per accedir als membres de la superclasse des de la subclasse:</p>

    {% include definicio.html terme="super" definicio="Referència a la superclasse immediata. Permet accedir als constructors, mètodes i atributs de la classe pare." %}

    {% capture code_super_exemples %}
public class Gat extends Animal {
    private boolean esInterior;
    
    public Gat(String nom, int edat, boolean esInterior) {
        super(nom, edat); // Constructor de Animal
        this.esInterior = esInterior;
    }
    
    public void miolar() {
        System.out.println(nom + " fa miau");
    }
    
    @Override
    public void menjar() {
        System.out.println(nom + " menja elegantment");
        super.dormir(); // Crida al mètode dormir() de Animal després de menjar
    }
    
    @Override
    public void mostrarInfo() {
        super.mostrarInfo(); // Informació bàsica d'Animal
        System.out.println("Viu a l'interior: " + (esInterior ? "Sí" : "No"));
    }
}

// Exemple d'ús
public class ExempleHerencia {
    public static void main(String[] args) {
        Gos gos = new Gos("Rex", 3, "Pastor Alemany");
        Gat gat = new Gat("Misi", 2, true);
        
        System.out.println("=== Informació del gos ===");
        gos.mostrarInfo();
        gos.menjar();
        gos.bordar();
        
        System.out.println("\n=== Informació del gat ===");
        gat.mostrarInfo();
        gat.menjar();
        gat.miolar();
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_super_exemples %}

    <h3>Sobrescriptura de Mètodes (@Override)</h3>
    
    <p>La <strong>sobrescriptura</strong> permet a una subclasse proporcionar una implementació específica d'un mètode que ja està definit en la seva superclasse.</p>

    {% include warning_box.html
       contingut="<strong>Regles de sobrescriptura:</strong><br>
       • El mètode ha de tenir la mateixa signatura (nom, paràmetres, tipus de retorn)<br>
       • No pot ser més restrictiu en accessibilitat<br>
       • Ha d'usar l'anotació @Override per evitar errors<br>
       • Els mètodes finals, estàtics i privats no es poden sobrescriure"
    %}

    {% capture code_override_exemple %}
public class Vehicle {
    protected String marca;
    protected int any;
    
    public Vehicle(String marca, int any) {
        this.marca = marca;
        this.any = any;
    }
    
    public void arrancar() {
        System.out.println("El vehicle està arrencant...");
    }
    
    public void mostrarInfo() {
        System.out.println("Vehicle: " + marca + " (" + any + ")");
    }
    
    // Mètode final - no es pot sobrescriure
    public final void numeroSerie() {
        System.out.println("Número de sèrie: VH" + hashCode());
    }
}

public class Motocicleta extends Vehicle {
    private boolean teCarrozzeria;
    
    public Motocicleta(String marca, int any, boolean teCarrozzeria) {
        super(marca, any);
        this.teCarrozzeria = teCarrozzeria;
    }
    
    @Override
    public void arrancar() {
        System.out.println("La motocicleta arrenca amb un rugit!");
        super.arrancar(); // Opcional: cridar la implementació del pare
    }
    
    @Override
    public void mostrarInfo() {
        super.mostrarInfo();
        System.out.println("Carrosseria: " + (teCarrozzeria ? "Sí" : "No"));
    }
    
    // Mètode específic de Motocicleta
    public void ferCaballito() {
        System.out.println("La motocicleta fa un caballito!");
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_override_exemple %}

    {% include prompt-ai.html
       contingut="Per què no puc cridar un mètode privat de la superclasse des de la subclasse? Com puc accedir a mètodes de la classe pare?"
    %}
</div>

<div class="section">
    <h2 id="Unitat7_Bloc1_Seccio5">Polimorfisme</h2>
    
    <p>El <strong>polimorfisme</strong> permet que objectes de diferents classes puguin ser tractats com objectes d'una classe comuna, proporcionant implementacions específiques dels mètodes.</p>

    {% include definicio.html terme="Polimorfisme" definicio="Capacitat dels objectes de respondre de manera diferent al mateix missatge (mètode) segons el seu tipus real. Permet tractar objectes de diferents classes de manera uniforme." %}

    <h3>Polimorfisme per Herència</h3>
    
    {% capture code_polimorfisme_herencia %}
// Exemple amb la jerarquia Animal
public class ExemplePolimorfisme {
    public static void main(String[] args) {
        // Polimorfisme: variables de tipus Animal que apunten a objectes específics
        Animal animal1 = new Gos("Toby", 4, "Labrador");
        Animal animal2 = new Gat("Luna", 2, false);
        Animal animal3 = new Animal("Genèric", 1);
        
        // Array polimòrfic
        Animal[] animals = {animal1, animal2, animal3};
        
        // Comportament polimòrfic: cada animal respon diferent
        System.out.println("=== Comportament polimòrfic ===");
        for (Animal animal : animals) {
            animal.mostrarInfo(); // Crida la versió sobrescrita de cada classe
            animal.menjar();      // Comportament específic de cada tipus
            System.out.println("---");
        }
        
        // Casting per accedir a mètodes específics
        if (animal1 instanceof Gos) {
            Gos gos = (Gos) animal1;
            gos.bordar(); // Només disponible després del casting
        }
        
        if (animal2 instanceof Gat) {
            ((Gat) animal2).miolar(); // Casting directe
        }
    }
    
    // Mètode que accepta qualsevol Animal (polimorfisme de paràmetres)
    public static void cuidarAnimal(Animal animal) {
        System.out.println("Cuidant l'animal:");
        animal.mostrarInfo();
        animal.menjar();
        animal.dormir();
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_polimorfisme_herencia %}

    <h3>Operador instanceof i Casting</h3>
    
    <p>L'operador <code>instanceof</code> permet verificar el tipus real d'un objecte abans de fer un casting:</p>

    {% capture code_instanceof %}
public class GestorAnimals {
    
    public static void processarAnimal(Animal animal) {
        // Informació general (disponible per tots)
        animal.mostrarInfo();
        animal.menjar();
        
        // Comportament específic segons el tipus
        if (animal instanceof Gos) {
            Gos gos = (Gos) animal;
            gos.bordar();
            System.out.println("Aquest gos és de raça específica");
            
        } else if (animal instanceof Gat) {
            Gat gat = (Gat) animal;
            gat.miolar();
            System.out.println("Aquest gat té comportament felí");
            
        } else {
            System.out.println("Animal genèric");
        }
    }
    
    public static void main(String[] args) {
        Animal[] refugi = {
            new Gos("Max", 5, "Golden Retriever"),
            new Gat("Whiskers", 3, true),
            new Animal("Exòtic", 2)
        };
        
        for (Animal animal : refugi) {
            processarAnimal(animal);
            System.out.println("=" .repeat(30));
        }
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_instanceof %}

    <h3>Polimorfisme en Acció: Exemple Pràctic</h3>
    
    {% capture code_polimorfisme_practic %}
// Simulació d'un sistema de formes geomètriques
abstract class Forma {
    protected String color;
    
    public Forma(String color) {
        this.color = color;
    }
    
    // Mètodes abstractes (han de ser implementats per les subclasses)
    public abstract double calcularArea();
    public abstract double calcularPerimetre();
    
    // Mètode concret (opcional sobrescriure)
    public void mostrarInfo() {
        System.out.printf("Forma de color %s - Àrea: %.2f - Perímetre: %.2f%n",
                         color, calcularArea(), calcularPerimetre());
    }
}

class Rectangle extends Forma {
    private double ample, alt;
    
    public Rectangle(String color, double ample, double alt) {
        super(color);
        this.ample = ample;
        this.alt = alt;
    }
    
    @Override
    public double calcularArea() {
        return ample * alt;
    }
    
    @Override
    public double calcularPerimetre() {
        return 2 * (ample + alt);
    }
}

class Cercle extends Forma {
    private double radi;
    
    public Cercle(String color, double radi) {
        super(color);
        this.radi = radi;
    }
    
    @Override
    public double calcularArea() {
        return Math.PI * radi * radi;
    }
    
    @Override
    public double calcularPerimetre() {
        return 2 * Math.PI * radi;
    }
}

// Ús polimòrfic
public class CalculadoraFormes {
    public static void main(String[] args) {
        Forma[] formes = {
            new Rectangle("Blau", 5, 3),
            new Cercle("Vermell", 2.5),
            new Rectangle("Verd", 4, 4)
        };
        
        double areaTotal = 0;
        
        System.out.println("=== Càlcul polimòrfic ===");
        for (Forma forma : formes) {
            forma.mostrarInfo(); // Polimorfisme en acció
            areaTotal += forma.calcularArea();
        }
        
        System.out.printf("\nÀrea total de totes les formes: %.2f%n", areaTotal);
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_polimorfisme_practic %}

    {% include success_box.html
       contingut="<strong>Avantatges del polimorfisme:</strong><br>
       • Codi més flexible i extensible<br>
       • Facilita la reutilització i el manteniment<br>
       • Permet tractar objectes diversos de manera uniforme<br>
       • Base per a molts patrons de disseny"
    %}
</div>

<div class="section">
    <h2 id="Unitat7_Bloc1_Seccio6">Composició vs Herència</h2>
    
    <p>La <strong>composició</strong> és una alternativa a l'herència que consisteix a construir classes utilitzant objectes d'altres classes com a components interns.</p>

    {% include definicio.html terme="Composició" definicio="Relació 'té un' on una classe conté objectes d'altres classes com a atributs. És una alternativa a l'herència que proporciona major flexibilitat." %}

    <h3>Diferències entre Herència i Composició</h3>
    
    <table class="responsive-table">
        <thead>
            <tr>
                <th>Aspecte</th>
                <th>Herència (és un)</th>
                <th>Composició (té un)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Relació</strong></td>
                <td>Gos "és un" Animal</td>
                <td>Cotxe "té un" Motor</td>
            </tr>
            <tr>
                <td><strong>Acoblament</strong></td>
                <td>Fort (subclasse depèn de superclasse)</td>
                <td>Dèbil (classes independents)</td>
            </tr>
            <tr>
                <td><strong>Flexibilitat</strong></td>
                <td>Limitada (una sola superclasse)</td>
                <td>Alta (múltiples components)</td>
            </tr>
            <tr>
                <td><strong>Reutilització</strong></td>
                <td>Per herència</td>
                <td>Per delegació</td>
            </tr>
            <tr>
                <td><strong>Canvis en runtime</strong></td>
                <td>Impossible</td>
                <td>Possible</td>
            </tr>
        </tbody>
    </table>

    <h3>Exemple de Composició</h3>
    
    {% capture code_composicio_exemple %}
// Components independents
class Motor {
    private String tipus;
    private int potencia;
    
    public Motor(String tipus, int potencia) {
        this.tipus = tipus;
        this.potencia = potencia;
    }
    
    public void arrancar() {
        System.out.println("Motor " + tipus + " arrencant (" + potencia + " CV)");
    }
    
    public void aturar() {
        System.out.println("Motor " + tipus + " aturat");
    }
    
    public String getTipus() { return tipus; }
    public int getPotencia() { return potencia; }
}

class Roda {
    private double diametre;
    private String tipus;
    
    public Roda(double diametre, String tipus) {
        this.diametre = diametre;
        this.tipus = tipus;
    }
    
    public void girar() {
        System.out.println("Roda " + tipus + " de " + diametre + "\" girant");
    }
    
    public double getDiametre() { return diametre; }
    public String getTipus() { return tipus; }
}

// Classe principal que usa composició
class Cotxe {
    private String marca;
    private String model;
    private Motor motor;        // Composició: Cotxe "té un" Motor
    private Roda[] rodes;       // Composició: Cotxe "té" Rodes
    
    public Cotxe(String marca, String model, Motor motor) {
        this.marca = marca;
        this.model = model;
        this.motor = motor;
        
        // Crear rodes per defecte
        this.rodes = new Roda[4];
        for (int i = 0; i < 4; i++) {
            rodes[i] = new Roda(17.0, "Estàndard");
        }
    }
    
    // Delegar comportament al motor
    public void arrancar() {
        System.out.println(marca + " " + model + " arrencant:");
        motor.arrancar();
    }
    
    public void aturar() {
        motor.aturar();
        System.out.println(marca + " " + model + " aturat");
    }
    
    // Delegar comportament a les rodes
    public void conduir() {
        System.out.println("Conduint el " + marca + " " + model);
        for (Roda roda : rodes) {
            roda.girar();
        }
    }
    
    // Canviar components en runtime (flexibilitat de la composició)
    public void canviarMotor(Motor nouMotor) {
        System.out.println("Canviant motor...");
        this.motor = nouMotor;
    }
    
    public void canviarRodes(Roda novaRoda) {
        for (int i = 0; i < rodes.length; i++) {
            rodes[i] = novaRoda;
        }
    }
    
    public void mostrarEspecificacions() {
        System.out.println("=== " + marca + " " + model + " ===");
        System.out.println("Motor: " + motor.getTipus() + " (" + motor.getPotencia() + " CV)");
        System.out.println("Rodes: " + rodes[0].getTipus() + " " + rodes[0].getDiametre() + "\"");
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_composicio_exemple %}

    <h3>Composició vs Herència: Exemple Comparatiu</h3>
    
    {% capture code_comparacio %}
// HERÈNCIA - Relació "és un"
class VehicleBase {
    protected String marca;
    protected void arrancar() { System.out.println("Arrencant vehicle"); }
}

class CotxeHerencia extends VehicleBase {
    public CotxeHerencia(String marca) {
        this.marca = marca;
    }
    
    @Override
    public void arrancar() {
        System.out.println("Arrencant cotxe " + marca);
    }
    
    // Problemàtic: Si volem canviar el tipus de motor, hem de crear subclasses
    // CotxeDiesel, CotxeGasolina, CotxeElectric...
}

// COMPOSICIÓ - Relació "té un"
class CotxeComposicio {
    private String marca;
    private Motor motor;
    
    public CotxeComposicio(String marca, Motor motor) {
        this.marca = marca;
        this.motor = motor;
    }
    
    public void arrancar() {
        System.out.println("Arrencant cotxe " + marca);
        motor.arrancar(); // Delegar al component
    }
    
    // Flexibilitat: podem canviar el motor dinàmicament
    public void canviarMotor(Motor nouMotor) {
        this.motor = nouMotor;
    }
}

// Exemple d'ús
public class ComparacioHerenciaComposicio {
    public static void main(String[] args) {
        // Composició: més flexibilitat
        Motor motorGasolina = new Motor("Gasolina", 150);
        Motor motorElectric = new Motor("Elèctric", 200);
        
        CotxeComposicio tesla = new CotxeComposicio("Tesla Model 3", motorElectric);
        tesla.arrancar();
        tesla.mostrarEspecificacions();
        
        // Canviar components en runtime
        tesla.canviarMotor(motorGasolina); // Simulació de canvi
        System.out.println("\nDesprés del canvi de motor:");
        tesla.mostrarEspecificacions();
    }
}
    {% endcapture %}
    {% include code-block.html lang="java" code=code_comparacio %}

    <h3>Quan Usar Herència vs Composició</h3>
    
    {% include info_box.html
       contingut="<strong>Usa HERÈNCIA quan:</strong><br>
       • Hi ha una relació clara 'és un' (Gos és un Animal)<br>
       • Vols aprofitar el polimorfisme<br>
       • Les classes estan estretament relacionades<br>
       • Necessites sobrescriure comportaments específics<br><br>
       
       <strong>Usa COMPOSICIÓ quan:</strong><br>
       • Hi ha una relació 'té un' (Cotxe té un Motor)<br>
       • Vols major flexibilitat i menys acoblament<br>
       • Necessites canviar comportaments en runtime<br>
       • Vols combinar funcionalitats de múltiples classes"
    %}

    {% include warning_box.html
       contingut="<strong>Principi:</strong> 'Favor composition over inheritance' - En general, prefereix la composició sobre l'herència per crear sistemes més flexibles i mantenibles."
    %}

    {% include prompt-ai.html
       contingut="Si tinc un 'Animal[] animals' amb gossos i gats, com puc cridar el mètode 'miolar()' només dels gats?"
    %}
</div>

<div class="section">
    <h2 id="Unitat7_Bloc1_Seccio7">Pràctiques</h2>
    
    <p>Exercicis per consolidar els conceptes de POO, herència, polimorfisme i composició.</p>

    {% include exercici.html 
       nom="Pràctica amb 'this'"
       dificultat="Fàcil"
       temps="10 min"
       descripcio="<p>Crea una classe <code>Cotxe</code> amb els atributs <code>marca</code>, <code>model</code> i <code>any</code>. Implementa:</p>
       <ul>
           <li>Constructor que utilitza <code>this</code> per assignar els paràmetres</li>
           <li>Mètode <code>setAny(int any)</code> que retorni <code>this</code> per encadenar</li>
           <li>Prova l'encadenament: <code>cotxe.setAny(2023).mostrarInfo()</code></li>
       </ul>"
    %}

    {% include exercici.html 
       nom="Herència Bàsica"
       dificultat="Fàcil"
       temps="15 min"
       descripcio="<p>Crea una jerarquia simple d'animals:</p>
       <ul>
           <li>Classe <code>Animal</code> amb nom i mètode <code>fer_so()</code></li>
           <li>Classe <code>Gos</code> que hereta d'Animal i sobrescriu <code>fer_so()</code></li>
           <li>Utilitza <code>super()</code> en el constructor del gos</li>
           <li>Crea objectes i prova el polimorfisme</li>
       </ul>"
    %}

    {% include exercici.html 
       nom="Composició vs Herència"
       dificultat="Mitjà"
       temps="20 min"
       descripcio="<p>Compara herència i composició creant dues versions d'un cotxe:</p>
       <ul>
           <li>Versió 1: <code>CotxeElectric extends Cotxe</code></li>
           <li>Versió 2: <code>Cotxe</code> amb atribut <code>Motor motor</code></li>
           <li>Implementa el mètode <code>arrancar()</code> en ambdues versions</li>
           <li>Reflexiona: quan és millor cada aproximació?</li>
       </ul>"
    %}

    {% include prompt-ai.html
       contingut="En quin cas és millor usar composició en lloc d'herència? Dona'm un exemple senzill per entendre-ho."
    %}
</div>